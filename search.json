[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "WEHI R Course",
    "section": "",
    "text": "Preface\nCode-based analysis is an increasingly important skill for modern biomedical research. The R coding language enables user-friendly data tidying and transformation, and creation of publication-ready graphics. R is also core to bioinformatics research, supporting all types of ’omics data analysis, and general statistical analysis too.\nDesigned for complete coding beginners, this course will introduce data wrangling, data visualisation, and bioinformatics analysis in R. The first 4 of 6 sessions will cover foundations of R, and user-friendly ‘tidyverse’ software, which is applicable to many areas of medical and clinical research, and beyond. The final two sessions will combine tidyverse and specialised bioinformatics software to perform an RNA seq analysis workflow.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-book",
    "href": "index.html#how-to-use-this-book",
    "title": "WEHI R Course",
    "section": "How to use this book",
    "text": "How to use this book\nThis course is divided into 6 sessions. In the first 3 sessions, we will cover the basics of R and the tidyverse, and in the last 3 sessions, we will apply these skills to a bioinformatics analysis (session 4 covers a more general analysis, while 5 & 6 focus on RNA-seq). Each session is divided into sections, which are designed to be completed in order. Each section contains a mix of text, code, and exercises.\nCode is shown in blue, with the output below it in grey, just like it would show up in the R console.\n\n# This is an R code block\n# You can run this code by copying it into the R console\n1 + 1\n\n[1] 2\n\n\nYou can run the code yourself by copying it (using the copy button in the top right of the code block) and pasting it into R on your computer.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "WEHI R Course",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nWe would like to thank Kerry Ko, Brendan Ansell and the WEHI education office for their work in organising and facilitating this course. We would also like to thank all of our instructors and tutors for making this course possible.\nThis course material for Sessions 5 and 6 was originally produced by Lucy Liu and modified for this workshop.\nWe acknowledge that this course is prepared and delivered on the unceded land of the Wurundjeri people of the Kulin Nation. We pay our respects to their Elders past, present, and emerging. We also acknowledge that sovereignty was never ceded, and that this always was and always will be Aboriginal land.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup",
    "section": "",
    "text": "Installing R and RStudio on a WEHI computer\nIf you’re using a WEHI computer, you can install R/RStudio through the managed software centre:",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "setup.html#installing-r-and-rstudio-on-a-non-wehi-computer",
    "href": "setup.html#installing-r-and-rstudio-on-a-non-wehi-computer",
    "title": "Setup",
    "section": "Installing R and RStudio on a non-WEHI computer",
    "text": "Installing R and RStudio on a non-WEHI computer\nOn a personal computer, you can download and install R/RStudio from the posit website.",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "setup.html#data-files",
    "href": "setup.html#data-files",
    "title": "Setup",
    "section": "Data files",
    "text": "Data files\nCommands to download the data files used in this course directly to your working directory will be provided during classes. Download buttons for the files also appear in this ebook when they are first introduced. For convenience, the files are also provided below:\n Download mousezempic_dosage_data.csv \n Download mousezempic_expression_data.tsv",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "session_1.html",
    "href": "session_1.html",
    "title": "1  Session 1: Introduction to R",
    "section": "",
    "text": "1.1 Using RStudio\nIn this session, we will get familiar with R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-usingRstudio",
    "href": "session_1.html#sec-usingRstudio",
    "title": "1  Session 1: Introduction to R",
    "section": "",
    "text": "1.1.1 What is R and RStudio?\nR is a free and popular statistical programming language, great for performing data analysis. RStudio is a free integrated development environment (IDE) that provides useful support features for writing code. During this course, we will learn how to use RStudio’s handy features like projects (which help us to keep track of different analyses) and the environment panel (which shows us all of our data/variables in one place).\n\n\n1.1.2 Creating a project\nRstudio Projects are a way we can organise our work in RStudio, so that we can resume where we left off and keep different analyses separate. Any time you start working on something new (like this course!) it is recommended that you start a new project. You can see the current project you’re working on, switch between projects or create a new project using the menu in the top right hand corner of RStudio:\n\n\n\nIn the top right hand corner of RStudio, you can see all of your projects\n\n\nTo begin this course, let’s make a new project. We’ll do this in a new directory (folder) so that everything stays organised:\n\n\n\nWe usually want to make a new project in its own directory (folder)\n\n\nNext, we need to tell R that we want to make a ‘New Project’ and not any of the other fancy things we could create:\n\n\n\nThere are many types of projects we can make in R, but for now we’ll stick with a regular project.\n\n\nFinally, we need to give our project an informative name:\n\n\n\nChoose a name that will help you remember what this project is about!\n\n\n\n\n\n\n\n\nName with underscores, not spaces\n\n\n\nYou’ll notice I named my project using an underscore (R_course) rather than a space (R course). In general, when coding we want to name things without spaces, so that it is clear to the computer that we are talking about a single entity (the ‘R_course’) as opposed to multiple things (‘R’ and ‘course’). We’ll revisit this idea later in the session in Section 1.4\n\n\n\n\n1.1.3 Creating an R script\nNow that our project is set up, we need to create a file to write our code in:\n\n\n\nHow to create a new R Script\n\n\nThis file is called an R Script. Don’t forget to save your R Script as you work so you don’t lose your progress! You can do this through the file menu or by using the keyboard shortcut Cmd-SCmd-S.\n\n\n1.1.4 Overview of the RStudio layout\nAt this point, your RStudio window should look like this, with four different panels visible:\n\n\n\nThe four panels of RStudio\n\n\nThis is what they’re used for:\n\nThe R Script panel. This is a text document where you can write code, and run it by highlighting the code or putting your cursor on that line, then pressing the ‘run’ button in the top-right corner or using the Cmd-EnterCmd-Enter keyboard shortcut.\nThe console. This is where the output (results) of your code will appear. You can also run code in the console, by typing it next to the &gt; symbol and pressing EnterEnter but it’s better to use the R Script, as the code you write there is saved and acts as a record of your work.\nThe environment panel. This is where the data and variables you use in your analysis will be listed. More on this later.\nThe files/plot/help panel.\n\nUnder the ‘files’ tab you can see the files in your current folder\nUnder the ‘plots’ tab you can view the plots you have created\nUnder the ‘help’ tab you can read manual pages to learn how to use functions\n\n\nAlthough there are other tabs for some of these panels, they are used for more niche things out of scope of this course. You can read more it in the RStudio documentation.\n\n\n1.1.5 Writing our first piece of code\nNow we are ready to write our bit of code! We’ll start with one of the most important concepts in programming: comments. Comments are lines of our script that begin with # and they are ignored by the computer: they are just notes that we write to ourselves. It’s really important to write ‘well-commented’ code, with plenty of comments that clearly explain what your code is doing, so that your script can easily be understood by whoever looks at it next (whether this is someone else or you revisiting an analysis many months later!)\n\n\n\n\n\n\nDon’t forget your #\n\n\n\nIf you forget the # at the start of your comment, R will try to interpret your notes as actual code, and you’ll get an error message:\n\noops I forgot the hashtag\n\nError in parse(text = input): &lt;text&gt;:1:6: unexpected symbol\n1: oops I\n         ^\n\n\n\n\nDuring this course, we will practice writing well-commented code, but here is an example of how we could write comments to explain the code for one plus one:\n\n# calculate one plus one\n1 + 1 # the + symbol means plus\n\nNote that comments can be written on their own line or at the end of a line after the code. You cannot write any code after a # on the same line, as R will ignore it. This is sometimes useful for ‘commenting out’ code that you don’t want to run, but want to keep in your script for later use.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-maths",
    "href": "session_1.html#sec-maths",
    "title": "1  Session 1: Introduction to R",
    "section": "1.2 Practicing R code with maths",
    "text": "1.2 Practicing R code with maths\nTo practice running R code, let’s do some maths. Here’s how to code some basic mathematical operations in R:\n\n\n\n\n\n\n\n\nOperation\nCode\nExample\n\n\n\n\nAddition\n+\none plus one: 1 + 1\n\n\nSubtraction\n-\ntwo minus ten: 2 - 10\n\n\nMultiplication\n*\neight times 4: 8 * 4\n\n\nDivision\n/\nten divided by 3: 10 / 3\n\n\nExponents\n^\nthree squared: 3 ^ 2\n\n\nBrackets\n()\nsixteen divided by the result of three minus one: 16 / (3 - 1)\n\n\n\nLike in regular maths, R follows the order of operations. Here, the 3 + 2 in the brackets will be evaluated first, and then result will be multiplied by 7.\n\n# brackets evaluate first\n(3 + 2) * 7\n\n[1] 35\n\n\nYou might notice when running this code that before the output (result), there is a number one that looks like this: [1]. This relates to the length of our output, which here is just one single number (hence the 1). Later in the session we will write code with longer output, and the purpose of this number will become clearer, but you can ignore it for now.\n\n\n\n\n\n\nUsing whitespace in code\n\n\n\nAbove we used spaces between the numbers and mathematical operators in our code. R understands code without spaces too, but this makes it easier to read. Note that this is different to when we are naming things, when spaces are bad!\n\n# spaces don't matter in code\n3 ^ 2\n\n[1] 9\n\n# so both of these should give the same result\n3^2\n\n[1] 9\n\n\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. Which R expression would give me a result of 10?\n\n\n\n\n ✔(2 * 3) + (2 ^ 2)\n\n\n ✗(5 - 3) * 4\n\n\n ✗1 + 1\n\n\n ✗20 - 1\n\n\n\n\n\n\n2. What would be the result of running this line of R code: # test 1+1\n\n\n\n\n ✗1\n\n\n ✗2\n\n\n ✗An error\n\n\n ✔Nothing\n\n\n\n\n\n\n\nSolutions\n\n\n\n(2 * 3) + (2 ^ 2) is equal to 10. If you’re not sure, try copy-pasting this code into the console and running it! The best way to learn is by doing.\nThe code # test 1+1 is a comment, because it starts with a #. This means R ignores it: if you run this code, you won’t see any output in the console.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-comparisons",
    "href": "session_1.html#sec-comparisons",
    "title": "1  Session 1: Introduction to R",
    "section": "1.3 Comparisons",
    "text": "1.3 Comparisons\nR can perform comparisons, using the following notation:\n\n\n\nComparison\nCode\n\n\n\n\nEqual to\n==\n\n\nNot equal to\n!=\n\n\nGreater/less than\n&gt; or &lt;\n\n\nGreater/less than or equal to\n&gt;= or &lt;=\n\n\n\n\n\n\n\n\n\nMind your equal signs!\n\n\n\nBe careful to use double equal signs == when checking for equality. If you use only one, you’ll get an error:\n\n1 == 1 # this is TRUE\n\n[1] TRUE\n\n1 = 1 # this gives an error\n\nError in 1 = 1: invalid (do_set) left-hand side to assignment\n\n\n\n\nComparisons in R return either TRUE or FALSE:\n\n10 &gt; 10\n\n[1] FALSE\n\n10 &gt;= 10\n\n[1] TRUE\n\n\nYou can also negate the result of a comparison or any TRUE/FALSE value by using the ! operator before the expression.\n\n# gives FALSE (i.e. not TRUE)\n!TRUE\n\n[1] FALSE\n\n# gives TRUE: 1 is not equal to 2, but we've negated the result\n!(1 == 2)\n\n[1] TRUE\n\n\nThis is really useful for filtering data, which we will cover in Session 2\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What would be the result of running this R code: 10 &gt;= 10\n\n\n\n\n ✗10\n\n\n ✗FALSE\n\n\n ✔TRUE\n\n\n ✗An error\n\n\n\n\n\n\n2. Which of the following R expressions would give me a result of FALSE?\n\n\n\n\n ✗1 == 1\n\n\n ✗1 != (3 - 4) * 1\n\n\n ✗1 = 10\n\n\n ✔1 == 2\n\n\n\n\n\n\n3. What would be the result of running this R code: !TRUE\n\n\n\n\n ✔FALSE\n\n\n ✗TRUE\n\n\n ✗An error\n\n\n ✗Nothing\n\n\n\n\n\n\n\nSolutions\n\n\n\n10 &gt;= 10 is TRUE because 10 is equal to 10, and we are using the greater than or equal to operator, &gt;=.\n1 == 2 is the only expression that would give a result of FALSE. Be mindful that 1 = 10 is not a valid expression in R, and would give an error (since we need to use the double equal sign == for comparisons).\n!TRUE is FALSE because we are negating the value using !.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-variables",
    "href": "session_1.html#sec-variables",
    "title": "1  Session 1: Introduction to R",
    "section": "1.4 Variables",
    "text": "1.4 Variables\n\n1.4.1 What’s a variable?\nA variable (also known as an object) in R is like a label we can use to keep track of values. We assign (save) values to variables so that we can refer to them later.\nFor example, let’s say I use R to do some maths:\n\n(2 + 6) * 7\n\n[1] 56\n\n\nR outputs simply the result. To use this value later, I would need to assign the output to a variable.\nVariables are assigned with the assignment operator &lt;- (you can type this using the &lt;&lt; and -- keys, or use the shortcut alt-alt-).\n\n\n\n\n\n\nAssignment arrows\n\n\n\nYou might be familiar with assigning values to variables using the equal sign =, which is used in other programming languages and in maths. Although this does also work in R, it’s preferred to use the arrow &lt;- as this makes it really clear that a variable is being assigned. In this course we’ll be using &lt;-.\n\n\nReturning to our example, let’s save the result of the above calculation to a variable called my_number\n\n# assign the result to my_number\nmy_number &lt;- (2 + 6) * 7\n\nHere, R has performed the calculation to the right of the arrow ((2 + 6) * 7) and assigned the result of this to the my_number variable.\nYou’ll notice that this line of code doesn’t produce any output, because it has gone straight into our variable. If we want to know the value of my_number, we can either run it as a line of R code, like so:\n\nmy_number\n\n[1] 56\n\n\nOr, we can look at the environment panel in RStudio:\n\n\n\nWe can see our variables and their values in the environment panel\n\n\n\n\n1.4.2 Using variables in R code\nVariables can be used in place of values (e.g. numbers) in R code. For example, we can use the my_number variable in a calculation:\n\n# multiply my_number by 2\nmy_number * 2\n\n[1] 112\n\n\nAs the name suggests, variables can vary! We can assign a new value to a variable at any time:\n\n# change the value of my_number to 12\nmy_number &lt;- 12\nmy_number\n\n[1] 12\n\n\nBecause the right hand side of the arrow is evaluated first, you can also assign to a variable a calculation that involves itself:\n\n# add 5 to my_number\nmy_number &lt;- my_number + 5\nmy_number # value is now 17 since 12 + 5 = 17\n\n[1] 17\n\n\n\n\n\n\n\n\nCareful of cases!\n\n\n\nOne thing we need to be careful of when using variables is that R is case-sensitive. This means that MY_NUMBER is not the same as my_number:\n\n# create the my_number variable\nmy_number &lt;- (2 + 6) * 7\n\n# produces error because MY_NUMBER is not the same as my_number\nMY_NUMBER\n\nError: object 'MY_NUMBER' not found\n\n\n\n\nThere’s not really any harm in keeping variables around, but if you would like to remove them you can use the rm() function like so:\n\n# assign a variable\nmy_variable &lt;- 10\n\n# remove it\nrm(my_variable) # put the variable name inside the brackets\n\nWe’ll cover functions in more detail in Section 1.5.\nIf you want to remove ALL the variables you’ve assigned and start fresh, you can use the broom button in the environment panel:\n\n\n\nThe broom button removes all your variables\n\n\nTry using the broom to clean up your environment after completing the practice exercises at the end of this section.\n\n\n1.4.3 Choosing good variable names\nWhen naming variables, we need to follow these rules:\n\n\n\n\n\n\n\nRule\nExamples\n\n\n\n\nVariable names can only contain letters, numbers and underscores\n✅ Allowed: my_number, ID_2\n❌ Not allowed: my_number!, price$\n\n\nVariable names can’t start with a number\n✅ Allowed: my_number_2\n❌ Not allowed: 2_my_number\n\n\nVariable names can’t contain spaces\n✅ Allowed: my_number\n❌ Not allowed: my number\n\n\n\nIf we try to create a variable that breaks these rules, R will give an error:\n\n# gives an error because we use a non-allowed character\npercentage% &lt;- 100\n\nError in parse(text = input): &lt;text&gt;:2:11: unexpected input\n1: # gives an error because we use a non-allowed character\n2: percentage% &lt;- 100\n             ^\n\n\n\n# gives an error because we start with a number\n1place &lt;- 1\n\nError in parse(text = input): &lt;text&gt;:2:2: unexpected symbol\n1: # gives an error because we start with a number\n2: 1place\n    ^\n\n\n\n# gives an error because we have a space\nmy age &lt;- 5\n\nError in parse(text = input): &lt;text&gt;:2:4: unexpected symbol\n1: # gives an error because we have a space\n2: my age\n      ^\n\n\nRStudio will try to help you spot these mistakes in your script, by using underlining them in red:\n\n\n\nRStudio underlines errors in your code\n\n\nBeyond those three key rules, there are also some best practices we should try to keep in mind when naming our variables:\n\nTry not to use capital letters. Since R is case sensitive, Genes is a different variable to genes. It can be easy to forget to use a capital letter, so it’s generally better to avoid them if you can.\nUse descriptive names. It’s better to use a longer name that describes what the variable is for, rather than a short name that doesn’t give much information. For example, gene_counts is better than gc. You’ll thank yourself later when you come back to your code and can’t remember what gc stands for!\nAvoid using names that are already used in R. For example, mean is a function in R that calculates the average of a set of numbers. If you use mean as a variable name, this could lead to errors: how will R know if you are referring to the function mean or your variable mean?\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. How would I assign the value of 10 to a variable called my_variable?\n\n\n\n\n ✗10\n\n\n ✔my_variable &lt;- 10\n\n\n ✗my_variable = 10\n\n\n ✗my variable &lt;- 10\n\n\n\n\n\n\n2. I have assigned the value of 10 to a variable called my_variable as in Q1. What then would be the output from running this line of R code: my_variable + 5?\n\n\n\n\n ✗An error\n\n\n ✗Nothing\n\n\n ✗5\n\n\n ✔15\n\n\n\n\n\n\n3. I have assigned the value of 10 to a variable called my_variable as in Q1. If I run the code my_variable &lt;- my_variable + 10, what is the new value of my_variable?\n\n\n\n\n ✗10\n\n\n ✗25\n\n\n ✔20\n\n\n ✗my_variable\n\n\n\n\n\n\n4. Which of the following is a valid variable name?\n\n\n\n\n ✗10th_place\n\n\n ✗(n)_mice\n\n\n ✗disease status\n\n\n ✔expression_level\n\n\n\n\n\n\n\nSolutions\n\n\n\nmy_variable &lt;- 10 is the correct way to assign the value of 10 to a variable called my_variable. Remember the arrow &lt;- is used for assignment in R.\nThe output would be 15, since my_variable is 10 and we are adding 5 to it.\nThe new value of my_variable would be 20, since we are adding 10 to the current value of my_variable (which is 10). Note that even though we added 5 to my_variable earlier, this value is not saved anywhere (since we didn’t assign it), so we are starting from the original value of 10.\nexpression_level is the only valid variable name. 10th_place starts with a number, (n)_mice contains brackets, and disease status contains a space.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-functions",
    "href": "session_1.html#sec-functions",
    "title": "1  Session 1: Introduction to R",
    "section": "1.5 Functions",
    "text": "1.5 Functions\n\n1.5.1 Functions and arguments\nFunctions are programs that take inputs (also known as arguments) and produce outputs. They have a name, followed by round brackets () which contain the arguments.\nFor example, when we used the code rm(my_variable) earlier, the function rm() was taking the input (argument) my_variable and producing the output of deleting that variable.\nSome functions have multiple arguments, which are specified by separating them with commas. Arguments have a set order in which they can be given, or they can be referred to specifically by their name (using a equal sign = to provide a value).\nAs an example, the round() function rounds a number to a specified number of decimal places. The first argument is the number to be rounded, and the second argument is the number of decimal places to round to.\n\n# we'll use this decimal to demonstrate the round function\ndecimal &lt;- 3.14159\n\n# round to 3 decimal places\nround(decimal, digits = 3)\n\n[1] 3.142\n\n# we don't have to specify the argument name if we provide the arguments in the correct order\nround(decimal, 3)\n\n[1] 3.142\n\n\nWe can see that both of our calls to the round() function produced the same result, but the first is easier to understand since we explicitly specified the argument.\nMany arguments have default values so you don’t need to specify every argument for every function. For example, the round() function has a default value of 0 for the digits argument, so if you don’t specify it, the number will be rounded to the nearest whole number.\n\nround(decimal)\n\n[1] 3\n\n\n\n\n\n\n\n\nCommon errors with functions\n\n\n\nHere are some common errors you might encounter when using functions. Have a look at the code below and read the error messages to see how the two relate. This will help you to fix typos/errors in your own code.\n\n# forgot to enclose the arguments in brackets\nround 3.14159\n\nError in parse(text = input): &lt;text&gt;:2:7: unexpected numeric constant\n1: # forgot to enclose the arguments in brackets\n2: round 3.14159\n         ^\n\n\n\n# forgot the comma between the arguments\nround(3.14159 digits = 3)\n\nError in parse(text = input): &lt;text&gt;:2:15: unexpected symbol\n1: # forgot the comma between the arguments\n2: round(3.14159 digits\n                 ^\n\n\n\n# spelt the argument name wrong\nround(3.14159, digts = 3)\n\nError in round(3.14159, digts = 3): unused argument (digts = 3)\n\n\n\n# forgot to close the brackets\nround(3.14159, digits = 3\n\nError in parse(text = input): &lt;text&gt;:3:0: unexpected end of input\n1: # forgot to close the brackets\n2: round(3.14159, digits = 3\n  ^\n\n\nRStudio will also flag some of these sorts of issues in the script panel, although it won’t catch everything:\n\n\n\nRStudio can help you to find errors in your function calls before you run the code\n\n\n\n\n\n\n1.5.2 Getting help with functions: within R\nWhen you’re using a function, you might not know what arguments it takes, what they do or what their default values are. Nobody can remember all of this information, so one of the most important skills in programming is learning how to access help.\nYou can access the help pages for a function by typing ? followed by the name of the function:\n\n?round\n\nOr searching for the function in the help tab in RStudio:\n\n\n\nYou can search for functions directly in the help panel\n\n\nHere’s what the help page looks like for the round function:\n\n\n\nThe help page for the round function\n\n\nHelp pages can sometimes be quite technical or complicated– for example the help page for round also describes various other similar functions for rounding numbers. Often the most important section to look at is the ‘arguments’ one:\n\n\n\nHelp pages have a section for describing arguments\n\n\nYou can also see help for functions in the script panel, as you are typing your code:\n\n\n\nRStudio will show you a preview of the help page as you type a function name\n\n\nIt will also suggest you the names of arguments:\n\n\n\nRStudio also suggests arguments for functions as you type\n\n\nSo, if you get stuck with how to use a function, wait a moment and see if RStudio will suggest what you need.\n\n\n1.5.3 Getting help with functions: beyond R\nSometimes, the R help pages can be pretty tricky to understand, and they can’t help you if you don’t know the name of the function you need! In this course, we’ll learn about lots of different functions, but even R experts need to look things up sometimes. Here are some good resources for getting help:\n\nGoogle. R is a pretty popular language, so if you google ‘how to do x in R’, you’ll probably find an answer\nPackage vignettes. Many R packages have vignettes, which are short guides to using the package. Once you find the name of a package you might want to use, you should go through their vignettes to see what functions are available and how to use them.\nChatGPT (or similar). AI tools can be really useful in helping you write code, although make sure you double-check the results because it can make mistakes\nAsk others! There are lots of R users, and working together is often the best way to solve problems. This could be through online forums, like StackOverflow or in-person\n\nNo matter where you get your help, try to make sure you understand the code you find. Reading the help pages for new functions, or asking an AI like ChatGPT to explain what code is doing is a great way to expand your R knowledge. Additional resources are listed in the “Useful references” section of “Further reading”.\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What would be the result of running this R code: round(3.14159, digits = 2)\n\n\n\n\n ✗3.14159\n\n\n ✗3.141\n\n\n ✔3.14\n\n\n ✗3\n\n\n\n\n\n2. Look up the help pages for the following functions, and describe what they do:\n\nmean()\nSys.Date()\nsin()\n\n\n3. What is wrong with this line of R code: round(3.14159, digits = 3\n\n\n\n\n ✗Digits is not a valid argument for the round function\n\n\n ✗You need to use a double equal sign == for the digits argument\n\n\n ✗You don’t need to specify the digits argument\n\n\n ✔You need to close the brackets at the end of the line\n\n\n\n\n\n\n4. Which of the following lines of R code will run without error?\n\n\n\n\n ✗rm(my_variable\n\n\n ✗round(3.14159, Digits = 3)\n\n\n ✗round(3.14159 digits = 3)\n\n\n ✔round(3.14159, 3)\n\n\n\n\n\n\n\nSolutions\n\n\n\nThe result of running round(3.14159, digits = 2) would be 3.14. Remember the round() function rounds the number 3.14159 to 2 decimal places, according to the digits argument.\nThe mean() function calculates the average of a set of numbers, Sys.Date() returns the current date, and sin() calculates the sine of an angle (in radians).\nThe line of R code round(3.14159, digits = 3 is missing a closing bracket at the end, which is why it would produce an error.\nThe line of R code round(3.14159, 3) will run without error. The other lines of code have errors: rm(my_variable is missing a closing bracket, round(3.14159, Digits = 3) has a typo in the argument name (argument names are case sensitive), and round(3.14159 digits = 3) is missing a comma between the arguments. Remember that we don’t always need to specify the argument names if we provide the arguments in the correct order, which is why we could omit the digits = part in the correct line of code.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-dataTypes",
    "href": "session_1.html#sec-dataTypes",
    "title": "1  Session 1: Introduction to R",
    "section": "1.6 Data types",
    "text": "1.6 Data types\nEvery variable in R has a ‘type’. The type tells R what kind of data it is and consequently what it can and can’t do with the data. For example, it makes sense to perform mathematical functions like multiplication or division on numbers but not on words.\nThere are three basic types of data in R:\n\n\n\n\n\n\n\n\nType\nDescription\nExamples\n\n\n\n\nlogical\nalso known as ‘boolean’, true or false\nTRUE\nFALSE\n\n\nnumeric\nnumbers\n1\n0.523\n10000\n\n\ncharacter\ntext/numbers surrounded by quotation marks (double \"\" or single ''). Also known as a ‘string’\n'hello'\n\"cat\"\n\"my name is...\"\n\n\n\nThese are called ‘atomic’ data types as they are the most basic types of data from which other data types derive.\nYou can find the type of something using the class() function:\n\nclass(TRUE)\n\n[1] \"logical\"\n\nclass(1)\n\n[1] \"numeric\"\n\n# whatever you put in quotation marks is always a character\nclass(\"hello\")\n\n[1] \"character\"\n\nclass(\"TRUE\")\n\n[1] \"character\"\n\nclass(\"123\")\n\n[1] \"character\"\n\n\nIt is important to know the type of your data because, as mentioned earlier, R will not let you perform certain operations on data of the wrong type. For example, you can’t add two characters together:\n\n# this works\n1 + 1\n\n[1] 2\n\n# but this gives an error\n\"1\" + \"1\"\n\nError in \"1\" + \"1\": non-numeric argument to binary operator\n\n\nNor can you use the logical operator ! on a character:\n\n# this works\n!TRUE\n\n[1] FALSE\n\n# but this gives an error\n!\"TRUE\"\n\nError in !\"TRUE\": invalid argument type\n\n\nYou’ll notice that the error messages for these two examples explain that R can’t perform the operation you’re asking it to do on that data type.\nIf you want to change the type of a piece of data, you can use the as.x() functions like (e.g.as.logical(), as.numeric(), and as.character()):\n\n# convert a number to a character\nas.character(100)\n\n[1] \"100\"\n\n# convert a character to a number\nas.numeric(\"100\")\n\n[1] 100\n\n\nOf course, it doesn’t make sense to make some conversions. In the example below, we can’t convert the word “hello” to a number, so we get an NA:\n\n# if a conversion is not possible, you'll get an NA\nas.numeric(\"hello\")\n\nWarning: NAs introduced by coercion\n\n\n[1] NA\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What are the three atomic data types in R?\n\n\n\n\n ✔logical, numeric, character\n\n\n ✗integer, float, string\n\n\n ✗dataset, vector, matrix\n\n\n ✗boolean, text, number\n\n\n\n\n\n\n2. How do you find the type of a piece of data in R?\n\n\n\n\n ✗You can’t\n\n\n ✗Using the type() function\n\n\n ✗Guess\n\n\n ✔Using the class() function\n\n\n\n\n\n\n3. How would you convert the character “TRUE” to a logical?\n\n\n\n\n ✗TRUE\n\n\n ✔as.logical(\"TRUE\")\n\n\n ✗You can’t convert a character to a logical\n\n\n ✗Using the logical() function\n\n\n\n\n\n4. What are the types of the following?\n\n11\n\"eleven\"\nTRUE\n!FALSE\n0.49826\n\"-0.53\"\nas.numeric(\"11\")\n\n\n\nSolutions\n\n\n\nThe three atomic data types in R are logical, numeric, and character.\nYou can find the type of a piece of data in R using the class() function.\nTo convert the character “TRUE” to a logical, you would use as.logical(\"TRUE\") (we always use ‘as…’ functions to convert between types).\nThe types are:\n\n11 is numeric\n\"eleven\" is character\nTRUE is logical\n!FALSE is logical\n0.49826 is numeric\n\"-0.53\" is character (even though it looks like a number, it is surrounded by quotation marks so it is a character)\nas.numeric(\"11\") is numeric (since we converted the character “11” to a number with the as.numeric() function)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-datastructures",
    "href": "session_1.html#sec-datastructures",
    "title": "1  Session 1: Introduction to R",
    "section": "1.7 Data structures",
    "text": "1.7 Data structures\nBeyond the atomic data types, R has more complex data structures that can store multiple values. These are the building blocks of data analysis in R. The most common data structures are vectors, matrices, and data frames.\nThis figure summarises their key differences:\n\n\n\nOverview of the three main data structures in R. 📷 credit: https://bookdown.org/introrbook/intro2r/\n\n\n\n1.7.1 Vectors\nA vector is a collection of values of the same atomic type. Values in a vector are laid out linearly, one after another.\nYou can create vectors with the c() function, like so:\n\n# a vector of numbers\nc(1, 2, 3)\n\n[1] 1 2 3\n\n# a vector of characters\nc(\"a\", \"vector\", \"of\", \"characters\")\n\n[1] \"a\"          \"vector\"     \"of\"         \"characters\"\n\n# a vector of logicals\nc(TRUE, FALSE, TRUE)\n\n[1]  TRUE FALSE  TRUE\n\n\nFun fact: the ‘c’ in c() stands for ‘combine’.\nThere are a few ways to see the contents of a vector. You can simply type the name of the vector into the console, which will print out the whole thing:\n\n# in these examples we will use the letters vector that is\n# pre-loaded in R. It contains the alphabet in lowercase\nletters\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\nYou’ll notice that, in addition to the [1] that we usually see printed next to the output, there is also a [20]. This number is telling us where we are up to in the vector (so [1] means that line of output starts with the first element, \"a\" and [20] means that line of output starts with the 20th element of the vector, \"t\").\nBut what if we don’t always want to print the whole thing? For long vectors, it’s handy to use the head() and tail() functions to inspect just a few values. By default, these print the first and last 6 elements of a vector (you can change that by setting the n argument).\n\n# use head() and tail() to take a quick look\nhead(letters)\n\n[1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\"\n\ntail(letters)\n\n[1] \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\nYou can also use functions to look at other features of a vector, like its type (using the class() function just as for single values) or its length (using the length() function):\n\n# find the class of a vector\nclass(letters)\n\n[1] \"character\"\n\n# find the length of a vector\nlength(letters)\n\n[1] 26\n\n\nJust like you can with single values, vectors can be assigned to variables:\n\npet_names &lt;- c(\"sprinkle\", \"lucky\", \"coco\")\n\nThese variables will show up in the ‘Environment’ tab in RStudio:\n\n\n\nThe environment panel shows vectors too\n\n\nYou’ll notice vector variables are displayed a little differently to those with single values. The type (chr, for character) is displayed first, followed by [1:3] which tells you that the pet_names vector has elements from 1 to 3 (in other words, it has a length of 3). This is particularly helpful when part of the vector is cut off, like in this picture!\n\n\n\n\n\n\nColon (:) notation for vectors\n\n\n\nIn programming, the colon : is typically used to create sequences of numbers. You can use it to create a sequence of numbers from a starting point to an ending point.\nFor example, 1:5 creates a vector of numbers from 1 to 5:\n\n1:5\n\n[1] 1 2 3 4 5\n\n\n\n\nR is a vectorised language, which means that many functions and operations (like *, + etc) work directly on vectors without you having to write extra code. For example, we can use the mean() function to calculate the average of a vector of numbers:\n\n# create a vector of numbers\nnumbers &lt;- c(1, 2, 3, 4, 5)\n\n# calculate the mean\nmean(numbers)\n\n[1] 3\n\n\nBecause the other data structures we’ll cover are built on vectors, this concept will be useful for them as well.\n\n\n1.7.2 Matrices\nA matrix is the two-dimensional extension of the vector– it stores a collection of values of the same type that are laid out in a grid with rows and columns. An example of this is a gene count matrices where each row represents a gene, each column represents a sample and therefore each cell represents the count for a particular gene in a particular sample.\nYou can create a matrix using the matrix() function. The first argument is the vector of values to be put into the matrix, and the nrow and ncol arguments specify the number of rows and columns in the matrix:\n\n# create a 2x2 matrix and assign it to gene_counts\ngene_counts &lt;- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2)\n\n# print the matrix\ngene_counts\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\nUsually though you would read in a matrix from a file (e.g. the gene count matrix from a sequencing experiment).\nMatrices are their own type of object in R:\n\nclass(gene_counts)\n\n[1] \"matrix\" \"array\" \n\n\nAnd they show up in the environment panel in RStudio under ‘Data’: \nThe rows and columns are usually labelled with names, although these names are considered metadata rather than being a part of the matrix. You can set them by assigning vectors of names to the rownames() and colnames() functions:\n\n# set row and column names\nrownames(gene_counts) &lt;- c(\"gene1\", \"gene2\")\ncolnames(gene_counts) &lt;- c(\"sample1\", \"sample2\")\n\n# print the matrix, now with names!\ngene_counts\n\n      sample1 sample2\ngene1       1       3\ngene2       2       4\n\n\n\n\n1.7.3 Data frames\nData frames are similar to matrices in that they store data in rows and columns. The difference is each column can have a different type: for example you could have a column of gene names (character), a column of gene counts (numeric) and another column telling you whether or not the gene is protein-coding (logical). For this reason, data frames are the most common data structure used in R.\nYou can create a data frame using the data.frame() function. The arguments are vectors of values to be put into the data frame, with the names of the vectors becoming the column names:\n\n# create a data frame\nmouse_facts &lt;- data.frame(\n  name = c(\"mickey\", \"minnie\", \"stuart\"),\n  age = c(12, 8, 16),\n  weight = c(39.7, 42.2, 46.3)\n)\n\n# print the data frame\nmouse_facts\n\n    name age weight\n1 mickey  12   39.7\n2 minnie   8   42.2\n3 stuart  16   46.3\n\n\nWhen creating a data frame, it’s important that all vectors are the same length. If they’re not, you’ll get an error:\n\nmouse_facts &lt;- data.frame(\n  name = c(\"mickey\", \"minnie\", \"stuart\"),\n  age = c(12, 8), # forgot to add stuart's age!\n  weight = c(39.7, 42.2, 46.3)\n)\n\nError in data.frame(name = c(\"mickey\", \"minnie\", \"stuart\"), age = c(12, : arguments imply differing number of rows: 3, 2\n\n\nFor the rest of this section, we’ll use the iris data set that comes pre-loaded in R. This is a bigger data set that contains measurements of different species of iris flowers, and will help us to learn how to work with data frames in R.\nFirst, let’s load in the dataset using the data() function:\n\ndata(iris)\n\niris has the class data.frame:\n\nclass(iris)\n\n[1] \"data.frame\"\n\n\nJust like for vectors, there are functions to look at the contents of a data frame. This is useful as printing the whole data frame can be overwhelming if it’s large (try printing iris and see for yourself!). The head() and tail() functions work the same way as for vectors:\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\ntail(iris)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n145          6.7         3.3          5.7         2.5 virginica\n146          6.7         3.0          5.2         2.3 virginica\n147          6.3         2.5          5.0         1.9 virginica\n148          6.5         3.0          5.2         2.0 virginica\n149          6.2         3.4          5.4         2.3 virginica\n150          5.9         3.0          5.1         1.8 virginica\n\n\nYou can also use the View() function to open the data frame in a new tab in RStudio:\n\n# don't forget the capital V!\nView(iris)\n\nThis will open a new tab in RStudio with the data frame displayed in a spreadsheet-like format, where you can sort and filter the columns to get a better view of the data:\n\n\n\nThe View() function opens the data frame in a new tab in RStudio\n\n\nAnother way to view the data frame is by clicking on its name in the environment panel:\n\n\n\nClicking on the data frame’s name in the environment panel opens it in the viewer\n\n\nThis panel also shows you the names and types of the columns in the data frame. You might notice that the Species is described as a factor, which is a special type of data in R that we’ll cover in ?sec-session03.\nBefore the column names, you’ll see the $ symbol. The dollar sign $ is a shortcut used in R to access columns of a data frame. For example, to access the Petal.Width column of the iris data frame, you can use iris$Petal.Width:\n\niris$Petal.Width\n\n  [1] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 0.2 0.2 0.1 0.1 0.2 0.4 0.4 0.3\n [19] 0.3 0.3 0.2 0.4 0.2 0.5 0.2 0.2 0.4 0.2 0.2 0.2 0.2 0.4 0.1 0.2 0.2 0.2\n [37] 0.2 0.1 0.2 0.2 0.3 0.3 0.2 0.6 0.4 0.3 0.2 0.2 0.2 0.2 1.4 1.5 1.5 1.3\n [55] 1.5 1.3 1.6 1.0 1.3 1.4 1.0 1.5 1.0 1.4 1.3 1.4 1.5 1.0 1.5 1.1 1.8 1.3\n [73] 1.5 1.2 1.3 1.4 1.4 1.7 1.5 1.0 1.1 1.0 1.2 1.6 1.5 1.6 1.5 1.3 1.3 1.3\n [91] 1.2 1.4 1.2 1.0 1.3 1.2 1.3 1.3 1.1 1.3 2.5 1.9 2.1 1.8 2.2 2.1 1.7 1.8\n[109] 1.8 2.5 2.0 1.9 2.1 2.0 2.4 2.3 1.8 2.2 2.3 1.5 2.3 2.0 2.0 1.8 2.1 1.8\n[127] 1.8 1.8 2.1 1.6 1.9 2.0 2.2 1.5 1.4 2.3 2.4 1.8 1.8 2.1 2.4 2.3 1.9 2.3\n[145] 2.5 2.3 1.9 2.0 2.3 1.8\n\n\nTry typing this code into your R script. You’ll notice once you write iris$, RStudio will list out all of the columns like so:\n\n\n\nRStudio will suggest column names as you type\n\n\nYou can navigate through these suggestions using the up and down arrow keys, and press EnterEnter or TabTab to select the column you want.\nThese columns are vectors, so you can use the functions we’ve learned about so far to work with them:\n\n# find the class of the Petal.Width column\nclass(iris$Petal.Width)\n\n[1] \"numeric\"\n\n# find the average Petal.Width column\nmean(iris$Petal.Width)\n\n[1] 1.199333\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. Which of the following is NOT a valid vector in R?\n\n\n\n\n ✗c(TRUE, FALSE, FALSE)\n\n\n ✔(1, 2, 3, 4)\n\n\n ✗1:10\n\n\n ✗c(\"cat\", \"dog\", \"fish\")\n\n\n\n\n\n\n2. What is the result of running this R code: c(1, 2, 3) * 2?\n\n\n\n\n ✗2(1, 2, 3)\n\n\n ✗c(1, 2, 3, 1, 2, 3)\n\n\n ✗c(1, 2, 3, 2)\n\n\n ✔c(2, 4, 6)\n\n\n\n\n\n\n3. What is the difference between a matrix and a data frame?\n\n\n\n\n ✔A matrix has all elements of the same type, while a data frame can have different types in each column\n\n\n ✗They’re the same thing\n\n\n ✗A matrix can only contain numbers, while a data frame can contain numbers and text\n\n\n ✗A matrix is used for mathematical operations, while a data frame is used for data analysis\n\n\n\n\n\n\n4. I wrote this code to create a data frame, but it gave me an error. What is wrong with it?\n\nfavourite_fruits &lt;- data.frame(\n  fruit = c(\"apple\", \"banana\", \"cherry\"),\n  colour = c(\"red\", \"yellow\", \"red\"),\n  price = c(0.5, 0.3)\n)\n\n\n\n\n\n ✗The column names are not in quotation marks\n\n\n ✔The columns are not the same length: ‘fruit’ and ‘colour’ have 3 elements, but ‘price’ has 2\n\n\n ✗It’s not allowed to have character columns and numeric columns in the same data frame\n\n\n ✗You should use the tibble() function instead of data.frame()\n\n\n\n\n\n\n5. What is NOT a way that I could view the contents of a data frame in R?\n\n\n\n\n ✗Running the name of the data frame as code in the R script panel\n\n\n ✗Typing the name of the data frame into the console\n\n\n ✗Clicking on its name in the environment panel\n\n\n ✔Using the view() function\n\n\n\n\n\n\n6. I have created the mouse_facts data frame using the code below. How would I calculate the average age of the mice?\n\nmouse_facts &lt;- data.frame(\n  name = c(\"mickey\", \"minnie\", \"stuart\"),\n  age = c(12, 8, 16),\n  weight = c(39.7, 42.2, 46.3)\n)\n\n\n\n\n\n ✗mean(age)\n\n\n ✔mean(mouse_facts$age)\n\n\n ✗average(age)\n\n\n ✗average(mouse_facts$age)\n\n\n\n\n\n\n\nSolutions\n\n1. The vector (1, 2, 3, 4) is not a valid vector: you need to use the c() function to create a vector in R. The exception is the colon : notation, which creates a sequence of numbers.\n2. The result of running c(1, 2, 3) * 2 would be c(2, 4, 6). This is because R is a vectorised language, so the * operator multiplies each element of the vector by 2.\n3. The difference between a matrix and a data frame is that a matrix has all elements of the same type (could be character, logical or numeric), while a data frame can have different types in each column.\n4. The code to create the data frame favourite_fruits gave an error because the columns are not the same length: ‘fruit’ and ‘colour’ have 3 elements, but ‘price’ has 2. You can’t create a data frame with columns of different lengths. As for the other options, you can have character and numeric columns in the same data frame, the column names don’t need to be in quotation marks (although the code will work if they are), and the tibble() function is an alternative to data.frame() but either is fine.\n5. Using the view() function is not a way to view the contents of a data frame in R. The correct function is View() (with a capital ‘V’). All the other options are valid ways to view the contents of a data frame.\n6. To calculate the average age of the mice, you would use mean(mouse_facts$age). This is because the age column is part of the mouse_facts data frame, so you need to use the $ symbol to access it, and the function for calculating the average in R is mean().",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-readingin",
    "href": "session_1.html#sec-readingin",
    "title": "1  Session 1: Introduction to R",
    "section": "1.8 Reading in data",
    "text": "1.8 Reading in data\nSo far, we’ve explored the basics of R by creating our own data, or using built-in data objects like letters or iris. However, in real life analyses, we almost always need to read in data from files on our computers.\nIn this section we will use the file named mousezempic_dosage_data.csv, which you can download using the button below:\n Download the example data file \nPlace this file into the project directory you have made for this course (it’s generally a good idea to keep all the data and code for a certain analysis together). If you’d like to be more organised, try placing it in a folder called ‘data’.\nYou can also download the file by running the following R code (note that you will need to have created a ‘data’ folder inside your R project folder first):\n\ndownload.file(\"https://raw.githubusercontent.com/kzeglinski/new_wehi_r_course/refs/heads/main/data/mousezempic_dosage_data.csv\", \"data/mousezempic_dosage_data.csv\")\n\n\n1.8.1 Paths\nPaths tell R where to find the file you want to read in. They are strings of characters that first include the directory or series of directories in which a file is located, followed by the name of the file itself. For example, the path to a file called my_data.csv in a folder called data would be data/my_data.csv.\nIn this course, we will use RStudio to help us find the paths to our files, without needing to type them out ourselves. If you’re interested in learning more about paths, codeacademy has a nice simple article on them.\nTo find a file path easily in RStudio, you can use the file explorer panel. First, open it by clicking on the ‘Files’ tab in the bottom right panel of RStudio:\n\n\n\nThe file explorer panel in RStudio\n\n\nBy default, it will put you in your project directory. If you have data files in a different directory, you can navigate to that directory by clicking on the folders. Here, I have navigated to a folder on my desktop called ‘data’, which is inside the ‘R_course’ folder. Once you’re in the right place, to get the path for that folder, click on More &gt; Copy Folder Path to Clipboard:\n\n\n\nCopying the folder path to the clipboard\n\n\nThis will copy the path to the folder to your clipboard, which you can then paste into your R script. Then, you just need to add a / followed by the name of the file to the end of the path.\nFor example, the path to the folder in the above image is ~/Desktop/R_course/data, so the path to the mousezempic_dosage_data.csv file is ~/Desktop/R_course/data/mousezempic_dosage_data.csv.\n\n\n1.8.2 Reading data with functions\nNow that we know how to find our data, we can read it in. We’ll do this using a handy package called readr, that is part of the tidyverse.\n\n\n\n\n\n\nPackages in R\n\n\n\nPackages are collections of functions that other people have written to help us do specific tasks, beyond what is built-in to R itself. The tidyverse is a collection of packages that help to streamline data analysis in R. To use the tidyverse, we first need to install it. This is done using the install.packages() function, like so:\n\n# install the tidyverse package\n# only do this once\ninstall.packages(\"tidyverse\")\n\nWe only need to install a package once, but you must load it each time you open R. This is done using the library() function:\n\n# load the tidyverse package\n# do this every time you open R\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nYou’ll see some output from the tidyverse package when you load it, which is just telling you that some of the tidyverse functions have the same name as other functions in R.\nIf you forget to load a package, R will give you an error when you try to use that package’s functions, so it’s usually a good idea to load all the packages you’ll need at the start of your script to prevent you forgetting to load them the next time you open R. We’ll do this at the start of each session in this course.\n\n\nTo read in our data, we’ll use the read_delim() function from the readr package. This function takes in the path to the file you want to read in (in quotation marks \"\", as this is a character string) and returns as output a tibble (this is basically the same as a data frame).\n\nread_delim(\"~/Desktop/R_course/data/mousezempic_dosage_data.csv\")\n\n\n\n\n\n\n\nDelimiters\n\n\n\nThe ‘delim’ in ‘read_delim’ stands for delimiter, and refers to the character used to separates columns of the data.\nThe most common types of delimiter are comma-separated values (.csv files) and tab-separated values (.tsv files). Here’s an example of what they look like:\n\n\nexample.csv\n\nName, Age\nAndy, 10\nBob, 8\n\n\n\n\n\nexample.tsv\n\nName  Age\nAndy  10\nBob   8\n\nBy default read_delim() will guess your delimiter, so it’s easiest to use that to read files, no matter their format. However, if you read other people’s code, you might also encounter the read_tsv() and read_csv() functions which are specifically for reading in tab-separated and comma-separated files, respectively. It’s up to you which you use, just make sure to get the delimiter right! If you try to read in a file with the wrong delimiter, it’ll look like a mess.\n\n\nWhat happens if we use the wrong delimiter?\n\nAs an example, let’s try reading in our comma-separated file with read_tsv(), which is specifically for tab-separated files:\n\nread_tsv(\"~/Desktop/R_course/data/mousezempic_dosage_data.csv\")\n\n\n\nRows: 344 Columns: 1\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (1): mouse_strain,cage_number,weight_lost_g,replicate,sex,drug_dose_g,ta...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 344 × 1\n   mouse_strain,cage_number,weight_lost_g,replicate,sex,drug_dose_g,tail_lengt…¹\n   &lt;chr&gt;                                                                        \n 1 CD-1,1A,3.75,rep1,male,0.00181,18.7,39.1,1                                   \n 2 CD-1,1A,3.8,rep1,female,0.0018600000000000001,17.4,39.5,2                    \n 3 CD-1,1A,3.25,rep1,female,0.00195,18,40.3,3                                   \n 4 CD-1,1A,NA,rep1,NA,NA,NA,NA,4                                                \n 5 CD-1,1A,3.45,rep1,female,0.00192999999999999,19.3,36.7,5                     \n 6 CD-1,1A,3.65,rep1,male,0.0019,20.6,39.3,6                                    \n 7 CD-1,1A,3.625,rep1,female,0.00181,17.8,38.9,7                                \n 8 CD-1,1A,4.675,rep1,male,0.00195,19.6,39.2,8                                  \n 9 CD-1,1A,3.475,rep1,NA,0.00192999999999999,18.1,34.1,9                        \n10 CD-1,1A,4.25,rep1,NA,0.0019,20.2,42,10                                       \n# ℹ 334 more rows\n# ℹ abbreviated name:\n#   ¹​`mouse_strain,cage_number,weight_lost_g,replicate,sex,drug_dose_g,tail_length_mm,initial_weight_g,id_num`\n\n\nWe can see that the data is all in one column, which is not what we want!\n\n\n\nDepending on where you have put your data, your path to the mousezempic_dosage_data.csv file may be different. You should be able to find the path by following the instructions in the ‘Paths’ section above.\n\n\n\n\n\n\nUsing RStudio to autocomplete paths\n\n\n\nAnother conveninent way to get the path of your file (so long as you are working within an R project) is to use a feature called ‘tab completion’. Within R projects, R can discover any files sitting in, or downstream of the project directory. So, assuming our mousezempic_dosage_data.csv file is located within a folder called ‘data’, if we start typing read_delim(\"data/mouse then press TabTab, R will auto-complete the full file path and close the quotes and bracket for us!\n\n\nNow, let’s take a look at the output of read_delim():\n\n\nRows: 344 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): mouse_strain, cage_number, replicate, sex\ndbl (5): weight_lost_g, drug_dose_g, tail_length_mm, initial_weight_g, id_num\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nThe first line tells us how many rows and columns are in the data. Then, the Column specification section tells you:\n\nWhat delimiter was used to separate values.\nWhich columns belong to each type. read_delim() is quite clever and will guess this for us, but it’s useful to check and make sure it’s correct.\n\nThen, the data will be printed out as a tibble.\n\n\n\n\n\n\nTibbles and data frames\n\n\n\nTibbles are a more modern version of data frames introduced in the tidyverse. They are very similar to data frames, but have some additional features like printing more nicely in the console.\nLet’s use iris to highlight the advantages of tibbles:\n\n# need to load the tidyverse package to use tibbles\n# see below for more information on loading packages\nlibrary(tidyverse)\n\nWhen we print a data frame, it shows every single row and column, which can be overwhelming if the data frame is large:\n\n\nClick here to print iris as a data frame!\n\n\n# print iris\niris\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1            5.1         3.5          1.4         0.2     setosa\n2            4.9         3.0          1.4         0.2     setosa\n3            4.7         3.2          1.3         0.2     setosa\n4            4.6         3.1          1.5         0.2     setosa\n5            5.0         3.6          1.4         0.2     setosa\n6            5.4         3.9          1.7         0.4     setosa\n7            4.6         3.4          1.4         0.3     setosa\n8            5.0         3.4          1.5         0.2     setosa\n9            4.4         2.9          1.4         0.2     setosa\n10           4.9         3.1          1.5         0.1     setosa\n11           5.4         3.7          1.5         0.2     setosa\n12           4.8         3.4          1.6         0.2     setosa\n13           4.8         3.0          1.4         0.1     setosa\n14           4.3         3.0          1.1         0.1     setosa\n15           5.8         4.0          1.2         0.2     setosa\n16           5.7         4.4          1.5         0.4     setosa\n17           5.4         3.9          1.3         0.4     setosa\n18           5.1         3.5          1.4         0.3     setosa\n19           5.7         3.8          1.7         0.3     setosa\n20           5.1         3.8          1.5         0.3     setosa\n21           5.4         3.4          1.7         0.2     setosa\n22           5.1         3.7          1.5         0.4     setosa\n23           4.6         3.6          1.0         0.2     setosa\n24           5.1         3.3          1.7         0.5     setosa\n25           4.8         3.4          1.9         0.2     setosa\n26           5.0         3.0          1.6         0.2     setosa\n27           5.0         3.4          1.6         0.4     setosa\n28           5.2         3.5          1.5         0.2     setosa\n29           5.2         3.4          1.4         0.2     setosa\n30           4.7         3.2          1.6         0.2     setosa\n31           4.8         3.1          1.6         0.2     setosa\n32           5.4         3.4          1.5         0.4     setosa\n33           5.2         4.1          1.5         0.1     setosa\n34           5.5         4.2          1.4         0.2     setosa\n35           4.9         3.1          1.5         0.2     setosa\n36           5.0         3.2          1.2         0.2     setosa\n37           5.5         3.5          1.3         0.2     setosa\n38           4.9         3.6          1.4         0.1     setosa\n39           4.4         3.0          1.3         0.2     setosa\n40           5.1         3.4          1.5         0.2     setosa\n41           5.0         3.5          1.3         0.3     setosa\n42           4.5         2.3          1.3         0.3     setosa\n43           4.4         3.2          1.3         0.2     setosa\n44           5.0         3.5          1.6         0.6     setosa\n45           5.1         3.8          1.9         0.4     setosa\n46           4.8         3.0          1.4         0.3     setosa\n47           5.1         3.8          1.6         0.2     setosa\n48           4.6         3.2          1.4         0.2     setosa\n49           5.3         3.7          1.5         0.2     setosa\n50           5.0         3.3          1.4         0.2     setosa\n51           7.0         3.2          4.7         1.4 versicolor\n52           6.4         3.2          4.5         1.5 versicolor\n53           6.9         3.1          4.9         1.5 versicolor\n54           5.5         2.3          4.0         1.3 versicolor\n55           6.5         2.8          4.6         1.5 versicolor\n56           5.7         2.8          4.5         1.3 versicolor\n57           6.3         3.3          4.7         1.6 versicolor\n58           4.9         2.4          3.3         1.0 versicolor\n59           6.6         2.9          4.6         1.3 versicolor\n60           5.2         2.7          3.9         1.4 versicolor\n61           5.0         2.0          3.5         1.0 versicolor\n62           5.9         3.0          4.2         1.5 versicolor\n63           6.0         2.2          4.0         1.0 versicolor\n64           6.1         2.9          4.7         1.4 versicolor\n65           5.6         2.9          3.6         1.3 versicolor\n66           6.7         3.1          4.4         1.4 versicolor\n67           5.6         3.0          4.5         1.5 versicolor\n68           5.8         2.7          4.1         1.0 versicolor\n69           6.2         2.2          4.5         1.5 versicolor\n70           5.6         2.5          3.9         1.1 versicolor\n71           5.9         3.2          4.8         1.8 versicolor\n72           6.1         2.8          4.0         1.3 versicolor\n73           6.3         2.5          4.9         1.5 versicolor\n74           6.1         2.8          4.7         1.2 versicolor\n75           6.4         2.9          4.3         1.3 versicolor\n76           6.6         3.0          4.4         1.4 versicolor\n77           6.8         2.8          4.8         1.4 versicolor\n78           6.7         3.0          5.0         1.7 versicolor\n79           6.0         2.9          4.5         1.5 versicolor\n80           5.7         2.6          3.5         1.0 versicolor\n81           5.5         2.4          3.8         1.1 versicolor\n82           5.5         2.4          3.7         1.0 versicolor\n83           5.8         2.7          3.9         1.2 versicolor\n84           6.0         2.7          5.1         1.6 versicolor\n85           5.4         3.0          4.5         1.5 versicolor\n86           6.0         3.4          4.5         1.6 versicolor\n87           6.7         3.1          4.7         1.5 versicolor\n88           6.3         2.3          4.4         1.3 versicolor\n89           5.6         3.0          4.1         1.3 versicolor\n90           5.5         2.5          4.0         1.3 versicolor\n91           5.5         2.6          4.4         1.2 versicolor\n92           6.1         3.0          4.6         1.4 versicolor\n93           5.8         2.6          4.0         1.2 versicolor\n94           5.0         2.3          3.3         1.0 versicolor\n95           5.6         2.7          4.2         1.3 versicolor\n96           5.7         3.0          4.2         1.2 versicolor\n97           5.7         2.9          4.2         1.3 versicolor\n98           6.2         2.9          4.3         1.3 versicolor\n99           5.1         2.5          3.0         1.1 versicolor\n100          5.7         2.8          4.1         1.3 versicolor\n101          6.3         3.3          6.0         2.5  virginica\n102          5.8         2.7          5.1         1.9  virginica\n103          7.1         3.0          5.9         2.1  virginica\n104          6.3         2.9          5.6         1.8  virginica\n105          6.5         3.0          5.8         2.2  virginica\n106          7.6         3.0          6.6         2.1  virginica\n107          4.9         2.5          4.5         1.7  virginica\n108          7.3         2.9          6.3         1.8  virginica\n109          6.7         2.5          5.8         1.8  virginica\n110          7.2         3.6          6.1         2.5  virginica\n111          6.5         3.2          5.1         2.0  virginica\n112          6.4         2.7          5.3         1.9  virginica\n113          6.8         3.0          5.5         2.1  virginica\n114          5.7         2.5          5.0         2.0  virginica\n115          5.8         2.8          5.1         2.4  virginica\n116          6.4         3.2          5.3         2.3  virginica\n117          6.5         3.0          5.5         1.8  virginica\n118          7.7         3.8          6.7         2.2  virginica\n119          7.7         2.6          6.9         2.3  virginica\n120          6.0         2.2          5.0         1.5  virginica\n121          6.9         3.2          5.7         2.3  virginica\n122          5.6         2.8          4.9         2.0  virginica\n123          7.7         2.8          6.7         2.0  virginica\n124          6.3         2.7          4.9         1.8  virginica\n125          6.7         3.3          5.7         2.1  virginica\n126          7.2         3.2          6.0         1.8  virginica\n127          6.2         2.8          4.8         1.8  virginica\n128          6.1         3.0          4.9         1.8  virginica\n129          6.4         2.8          5.6         2.1  virginica\n130          7.2         3.0          5.8         1.6  virginica\n131          7.4         2.8          6.1         1.9  virginica\n132          7.9         3.8          6.4         2.0  virginica\n133          6.4         2.8          5.6         2.2  virginica\n134          6.3         2.8          5.1         1.5  virginica\n135          6.1         2.6          5.6         1.4  virginica\n136          7.7         3.0          6.1         2.3  virginica\n137          6.3         3.4          5.6         2.4  virginica\n138          6.4         3.1          5.5         1.8  virginica\n139          6.0         3.0          4.8         1.8  virginica\n140          6.9         3.1          5.4         2.1  virginica\n141          6.7         3.1          5.6         2.4  virginica\n142          6.9         3.1          5.1         2.3  virginica\n143          5.8         2.7          5.1         1.9  virginica\n144          6.8         3.2          5.9         2.3  virginica\n145          6.7         3.3          5.7         2.5  virginica\n146          6.7         3.0          5.2         2.3  virginica\n147          6.3         2.5          5.0         1.9  virginica\n148          6.5         3.0          5.2         2.0  virginica\n149          6.2         3.4          5.4         2.3  virginica\n150          5.9         3.0          5.1         1.8  virginica\n\n\n\nBut when we print a tibble, only a small preview is shown, which is much easier to read:\n\n# print iris as a tibble\nas_tibble(iris)\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n\n\nIt also tells us the number of rows (150) and columns (5) in the data, as well as the types of each column (&lt;dbl&gt; is short for double, which is a type of numeric data).\nFor the purpose of this course, we can treat tibbles and data frames as the same thing. However, if you’re interested in learning more about tibbles, you can read about them here.\n\n\nNo matter which function you use to read in your data, R simply prints the values out in the console. To actually work with data in R, we need assign our data frame to a variable:\n\ndosage_data &lt;- read_delim(\"~/Desktop/R_course/data/mousezempic_dosage_data.csv\")\n\n\n\nRows: 344 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): mouse_strain, cage_number, replicate, sex\ndbl (5): weight_lost_g, drug_dose_g, tail_length_mm, initial_weight_g, id_num\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n1.8.3 Reading data through RStudio’s graphical interface\nYou can also read in data through RStudio’s graphical interface. This is a good way to get the code to read in data if you’re not sure how to do it yourself.\nTo do this, click on the ‘Import Dataset’ button in the environment panel (for our data, we will use the ‘from Text (readr)’ option):\n\n\n\nThe import dataset button in the environment panel\n\n\nThis will open a window where you can select the file you want to read in, like so:\n\n\n\nThe import dataset window in RStudio\n\n\nR will then generate the code to read in the data for you, and you can use the preview to check that it has worked ok:\n\n\n\nRStudio will then read in the data, and give you the code that it used\n\n\nYou can then copy this code and paste it into your script. This step is really important because not only does it helps you to learn how to read in data yourself, it keeps a record in the script of how you read in the data so that you can reproduce your analysis later.\n\n\n\nDon’t forget to paste the code into the script!!!\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What is a path?\n\n\n\n\n ✗A type of data in R\n\n\n ✗The data you want to analyse\n\n\n ✔A string of characters that tells R where to find a file\n\n\n ✗A function in R\n\n\n\n\n\n\n2. What is NOT a way to read in a file called my_data.tsv in R?\n\n\n\n\n ✗Using the read_delim() function\n\n\n ✗Using the ‘Import Dataset’ button in RStudio\n\n\n ✗Using the read_tsv() function\n\n\n ✔Using the read_csv() function\n\n\n\n\n\n\n3. What do we need to do before we can use functions from readr or any other R package?\n\n\n\n\n ✗Install it\n\n\n ✔Install it, then load it into our R session using the library() function\n\n\n ✗Download it\n\n\n ✗Look at the help page for the functions we want to use\n\n\n\n\n\n\n\nSolutions\n\n1. A path is a string of characters that tells R where to find a file. Note that it isn’t the data itself, but rather the location of the data.\n2. The read_csv() function is not a way to read in a file called my_data.tsv, because it is specifically for reading in comma-separated files, so it would not work for a tab-separated file like my_data.tsv.\n3. Before we can use functions from readr or any other R package, we need to install it, then load it into our R session using the library() function. Otherwise we will get an error message when we try to use the functions.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#summary",
    "href": "session_1.html#summary",
    "title": "1  Session 1: Introduction to R",
    "section": "1.9 Summary",
    "text": "1.9 Summary\n\nHere’s what we’ve learnt in this session:\n\nHow to create an R project (to keep our files organised) and how to write and run code from an R script (so that the code is saved as a record of our work)\nThe operators for basic maths (*, /, + and -) and comparisons (==, &lt;, &lt;= and !)\nHow to use functions and specify their arguments, as well as how to get help\nHow to assign variables using the &lt;- operator, and how to name them appropriately\nThe three basic atomic data types in R (character, numeric and logical)\nThree different data structures in R (vectors, matrices and data frames/tibbles)\nHow to find file paths using RStudio\nHow to load the readr package and use it to read in files\n\nTry the practice questions below to test your understanding!\n\n1.9.1 Practice questions\n\nWhat would be the result of evaluating the following expressions? You don’t need to know these off the top of your head, use R to help! (Hint: some expressions might give an error. Try to think about why)\n\n5 + 10\n100 &gt;= (5 + 2) ^ 2\n!(100 &gt; 1)\n500 = 5 * 100\n2fast &lt;- \"zoom\"\nround(428.195721, 2)\n?t.test\nclass(\"banana\")\nclass(as.numeric(\"500\"))\n\"1\" + \"10\"\nlength(1:100)\nsum(c(1, 2, 3, 4))\nhead(iris)\nmean(iris$Sepal.Width)\nread_tsv(\"gene_counts.csv\")\n\nWrite some R code to complete the right-hand side of this comparison: as.numeric(\"100\") * 3 ==\nI wrote the following R code, and got an error. How can I fix it?\n\n# the number of frogs I counted\nFrog_counts &lt;- c(11, 2, 4, 9, 10)\n\n# convert to a proportion: divide by the sum\nfrog_counts / sum(Frog_counts)\n\nError: object 'frog_counts' not found\n\n\nLoad the iris dataframe into your R session using data(iris). What is the median petal length? Show the code you used to calculate this.\nImagine I have a file called mouse_survival.tsv located in a folder with the path ~/Downloads/experimental_data/latest. Write a line of R code to read in this file and assign it to a variable called mouse_survival\n\n\n\nSolutions\n\n\nThe results of evaluating the expressions are:\n\n5 + 10 is 15\n100 &gt;= (5 + 2) ^ 2 is TRUE\n!(100 &gt; 1) is FALSE (although 100 is greater than 1, the ! operator negates this)\n500 = 5 * 100 gives an error because we need two equals signs == to check for equality in R. Actually this code is trying to assign the value of 5 * 100 to the variable 500, which is not allowed, because variable names can’t start with a number.\n2fast &lt;- \"zoom\" gives an error because variable names can’t start with a number\nround(428.195721, 2) is 428.2\n?t.test opens the help page for the t.test() function\nclass(\"banana\") is \"character\"\nclass(as.numeric(\"500\")) is \"numeric\"\n\"1\" + \"10\" gives an error because you can’t add two character strings together\nlength(1:100) is 100\nsum(c(1, 2, 3, 4)) is 10\nhead(iris) shows the first 6 rows of the iris data frame\nmean(iris$Sepal.Width) is the average of the Sepal.Width column in the iris data frame\nread_tsv(\"gene_counts.csv\") will try to read in gene_counts.csv as if it were tab-separated, which will result in all the data being in one column\n\nThe right-hand side of the comparison as.numeric(\"100\") * 3 == can be anything that results in 300 e.g. 300 or 299 + 1, for example\nThe error in the code is because the variable name Frog_counts is not the same as frog_counts. R is case-sensitive, so it thinks you are trying to divide a variable that doesn’t exist. To fix this, make sure all your variables have the same case (lowercase is better!):\n\n\n    # the number of frogs I counted\n    frog_counts &lt;- c(11, 2, 4, 9, 10)\n\n    # convert to a proportion: divide by the sum\n    frog_counts / sum(frog_counts)\n\n[1] 0.30555556 0.05555556 0.11111111 0.25000000 0.27777778\n\n\n\nTo calculate the median petal length in the iris data frame, you can use median(iris$Petal.Length)\nTo read in the mouse_survival.tsv file and assign it to a variable called mouse_survival, you could use red_delim(): mouse_survival &lt;- read_delim(\"~/Downloads/experimental_data/latest/mouse_survival.tsv\") or read_tsv(): mouse_survival &lt;- read_tsv(\"~/Downloads/experimental_data/latest/mouse_survival.tsv\").",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_2.html",
    "href": "session_2.html",
    "title": "2  Session 2: Working with data",
    "section": "",
    "text": "2.1 Chaining functions together with pipes\nIn this session we will learn how to manipulate and summarise data using the dplyr package (with a little help from the tidyr package too).\nBoth dplyr and tidyr are contained within the tidyverse (along with readr) so we can load all of these packages at once using library(tidyverse):\nPipes are a powerful feature of the tidyverse that allow you to chain multiple functions together. Pipes are useful because they allow you to break down complex operations into smaller steps that are easier to read and understand.\nFor example, take the following code:\nmy_vector &lt;- c(1, 2, 3, 4, 5)\nas.character(round(mean(my_vector)))\n\n[1] \"3\"\nWhat do you think this code does? It calculates the mean of my_vector, rounds the result to the nearest whole number, and then converts the result to a character. But the code is a bit hard to read because you have to start from the inside of the brackets and work your way out.\nInstead, we can use the pipe operator (%&gt;%) to chain these functions together in a more readable way:\nmy_vector &lt;- c(1, 2, 3, 4, 5)\nmy_vector %&gt;% mean() %&gt;% round() %&gt;% as.character()\n\n[1] \"3\"\nSee how the code reads naturally from left to right? You can think of the pipe as being like the phrase “and then”. Here, we’re telling R: “Take my_vector, and then calculate the mean, and then round the result, and then convert it to a character.”\nYou’ll notice that we didn’t need to specify the input to each function. That’s because the pipe automatically passes the output of the previous function as the first input to the next function. We can still specify additional arguments to each function if we need to. For example, if we wanted to round the mean to 2 decimal places, we could do this:\nmy_vector %&gt;% mean() %&gt;% round(digits = 2) %&gt;% as.character()\n\n[1] \"3\"\nR is clever enough to know that the first argument to round() is still the output of mean(), even though we’ve now specified the digits argument.\nTo type the pipe operator more easily, you can use the keyboard shortcut Cmd-shift-MCmd-shift-M (although once you get used to it, you might find it easier to type %&gt;% manually).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#sec-pipes",
    "href": "session_2.html#sec-pipes",
    "title": "2  Session 2: Working with data",
    "section": "",
    "text": "Plenty of pipes\n\n\n\nThere is another style of pipe in R, called the ‘base R pipe’ |&gt;, which is available in R version 4.1.0 and later. The base R pipe works in a similar way to the magrittr pipe (%&gt;%) that we use in this course, but it is not as flexible. We recommend using the magrittr pipe for now.\nFun fact: the magrittr package is named after the artist René Magritte, who made a famous painting of a pipe.\n\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What is NOT a valid way to re-write the following code using the pipe operator: round(sqrt(sum(1:10)), 1). If you’re not sure, try running the different options in the console to see which one gives the same answer.\n\n\n\n\n ✗1:10 %&gt;% sum() %&gt;% sqrt() %&gt;% round(1)\n\n\n ✔sum(1:10) %&gt;% sqrt(1) %&gt;% round()\n\n\n ✗1:10 %&gt;% sum() %&gt;% sqrt() %&gt;% round(digits = 1)\n\n\n ✗sum(1:10) %&gt;% sqrt() %&gt;% round(digits = 1)\n\n\n\n\n\n\n2. What is the output of the following code? letters %&gt;% head() %&gt;% toupper() Try to guess it before copy-pasting into R.\n\n\n\n\n ✗\"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n\n ✗\"a\" \"b\" \"c\" \"d\" \"e\" \"f\"\n\n\n ✗An error\n\n\n ✔\"A\" \"B\" \"C\" \"D\" \"E\" \"F\"\n\n\n\n\n\n\n\nSolutions\n\n\n\nThe invalid option is sum(1:10) %&gt;% sqrt(1) %&gt;% round(). This is because the sqrt() function only takes one argument, so you can’t specify 1 as an argument in addition to what is being piped in from sum(1:10). Note that some options used the pipe to send 1:10 to sum() (like 1:10 %&gt;% sum()), and others just used sum(1:10) directly. Both are valid ways to use the pipe, it’s just a matter of personal preference.\nThe output of the code letters %&gt;% head() %&gt;% toupper() is \"A\" \"B\" \"C\" \"D\" \"E\" \"F\". The letters vector contains the lowercase alphabet, and the head() function returns the first 6 elements of the vector. Finally, the toupper() function then converts these elements to uppercase.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#sec-dataManip",
    "href": "session_2.html#sec-dataManip",
    "title": "2  Session 2: Working with data",
    "section": "2.2 Basic data manipulation",
    "text": "2.2 Basic data manipulation\nTo really see the power of the pipe, we will use it together with the dplyr package that provides a set of functions to easily filter, sort, select, and summarise data frames. These functions are designed to work well with the pipe, so you can chain them together to create complex data manipulations in a readable format.\nFor example, even though we haven’t covered the dplyr functions yet, you can probably guess what the following code does:\n\n# use the pipe to chain together our data manipulation steps\nmousezempic_dosage_data %&gt;%\n  filter(cage_number == \"3E\") %&gt;%\n  pull(weight_lost_g) %&gt;%\n  mean()\n\nThis code filters the mousezempic_dosage_data data frame to only include data from cage 3E, then pulls out the weight_lost_g column, and finally calculates the mean of the values in that column. The first argument to each function is the output of the previous function, and any additional arguments (like the column name in pull()) are specified in the brackets (like round(digits = 2) from the previous example).\nWe also used the enter key after each pipe %&gt;% to break up the code into multiple lines to make it easier to read. This isn’t required, but is a popular style in the R community, so all the code examples in this session will follow this format.\nWe will now introduce some of the most commonly used dplyr functions for manipulating data frames. To showcase these, we will use the mousezempic_dosage_data that we practiced reading in last session. This imaginary dataset contains information on the weight lost by different strains of mice after being treated with different doses of MouseZempic®.\n\n# read in the data, like we did in session 1\nmousezempic_dosage_data &lt;- read_delim(\"~/Desktop/R_course/data/mousezempic_dosage_data.csv\")\n\n\n\nRows: 344 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): mouse_strain, cage_number, replicate, sex\ndbl (5): weight_lost_g, drug_dose_g, tail_length_mm, initial_weight_g, id_num\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nBefore we start, let’s use what we learned in the previous session to take a look at mousezempic_dosage_data:\n\n# it's a tibble, so prints nicely\nmousezempic_dosage_data\n\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nYou might also like to use View() to open the data in a separate window and get a closer look.\n\n\n\n\n\n\nUsing RStudio autocomplete\n\n\n\nAlthough it’s great to give our data a descriptive name like mousezempic_dosage_data, it can be a bit of a pain to type out every time. Luckily, RStudio has a handy autocomplete feature that can solve this problem. Just start typing the name of the object, and you’ll see it will popup:\n\n\n\nRStudio autocomplete\n\n\nYou can then press TabTab to autocomplete it. If there are multiple objects that start with the same letters, you can use the arrow keys to cycle through the options.\nTry using autocomplete this session to save yourself some typing!\n\n\n\n2.2.1 Sorting data\nOften, one of the first things you might want to do with a dataset is sort it. In dplyr, this is called ‘arranging’ and is done with the arrange() function.\n\n\n\nArrange orders rows by their values in one or more columns\n\n\nBy default, arrange() sorts in ascending order (smallest values first). For example, let’s sort the mousezempic_dosage_data data frame by the weight_lost_g column:\n\nmousezempic_dosage_data %&gt;%\n  arrange(weight_lost_g)\n\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 BALB C       2B                   2.7  rep2      female     0.00192\n 2 CD-1         3E                   2.85 rep2      female     0.00181\n 3 CD-1         3E                   2.85 rep2      female     0.00184\n 4 CD-1         3E                   2.9  rep2      female     0.00187\n 5 CD-1         2B                   2.9  rep2      female     0.00178\n 6 CD-1         1A                   2.9  rep3      female     0.00188\n 7 BALB C       2B                   2.9  rep1      female     0.00187\n 8 CD-1         3E                   2.92 rep3      female     0.00193\n 9 CD-1         2B                   2.98 rep1      &lt;NA&gt;       0.00179\n10 CD-1         2B                   3    rep1      female     0.00185\n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nIf we compare this to when we just printed our data above, we can see that the rows are now sorted so that the mice that lost the least weight are at the top.\nSometimes you might want to sort in descending order instead (largest values first). You can do this by putting the desc() function around your column name, inside arrange():\n\nmousezempic_dosage_data %&gt;%\n  # put desc() around the column name to sort in descending order\n  arrange(desc(weight_lost_g))\n\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n 1 Black 6      3E                   6.3  rep1      male      0.00221\n 2 Black 6      3E                   6.05 rep1      male      0.0023 \n 3 Black 6      3E                   6    rep2      male      0.0022 \n 4 Black 6      3E                   6    rep3      male      0.00222\n 5 Black 6      3E                   5.95 rep2      male      0.00223\n 6 Black 6      3E                   5.95 rep3      male      0.00229\n 7 Black 6      3E                   5.85 rep1      male      0.00213\n 8 Black 6      3E                   5.85 rep1      male      0.00217\n 9 Black 6      3E                   5.85 rep3      male      0.0023 \n10 Black 6      3E                   5.8  rep2      male      0.00229\n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nNow we can see the mice that lost the most weight are at the top.\n\n\n\n\n\n\nComments and pipes\n\n\n\nNotice how in the previous example we have written a comment in the middle of the pipe chain. This is a good practice to help you remember what each step is doing, especially when you have a long chain of functions, and won’t cause any errors as long as you make sure that the comment is on its own line.\nYou can also write comments at the end of the line, just make sure it’s after the pipe operator %&gt;%.\nFor example, these comments are allowed:\n\nmousezempic_dosage_data %&gt;% # a comment here is fine\n  # a comment here is fine\n  arrange(desc(weight_lost_g))\n\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n 1 Black 6      3E                   6.3  rep1      male      0.00221\n 2 Black 6      3E                   6.05 rep1      male      0.0023 \n 3 Black 6      3E                   6    rep2      male      0.0022 \n 4 Black 6      3E                   6    rep3      male      0.00222\n 5 Black 6      3E                   5.95 rep2      male      0.00223\n 6 Black 6      3E                   5.95 rep3      male      0.00229\n 7 Black 6      3E                   5.85 rep1      male      0.00213\n 8 Black 6      3E                   5.85 rep1      male      0.00217\n 9 Black 6      3E                   5.85 rep3      male      0.0023 \n10 Black 6      3E                   5.8  rep2      male      0.00229\n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nBut this will cause an error, because the # is before the pipe, so R treats it as part of the comment (notice how the %&gt;% has changed colour?) and doesn’t know how the two lines relate to each other. It tries to run them separately, which for the first line is ok (it will just print mousezempic_dosage_data):\n\nmousezempic_dosage_data # this comment will cause an error %&gt;%\n\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n  arrange(desc(weight_lost_g))\n\nError in eval(expr, envir, enclos): object 'weight_lost_g' not found\n\n\nBut for the second line, there is an error that R doesn’t know what the weight_lost_g object is. That’s because it’s a column in the mousezempic_dosage_data data frame, so R only knows what it is in the context of the pipe chain containing that data frame.\n\n\nYou can also sort by multiple columns by passing multiple column names to arrange(). For example, to sort by the strain first and then by the amount of weight lost:\n\n# sort by strain first, then by weight lost\nmousezempic_dosage_data %&gt;%\n  arrange(mouse_strain, weight_lost_g)\n\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 BALB C       2B                   2.7  rep2      female     0.00192\n 2 BALB C       2B                   2.9  rep1      female     0.00187\n 3 BALB C       2B                   3.2  rep2      female     0.00187\n 4 BALB C       2B                   3.25 rep1      female     0.00178\n 5 BALB C       2B                   3.25 rep3      male       0.00187\n 6 BALB C       2B                   3.25 rep3      female     0.00191\n 7 BALB C       2B                   3.3  rep1      male       0.00197\n 8 BALB C       2B                   3.3  rep1      female     0.00195\n 9 BALB C       2B                   3.32 rep3      female     0.00199\n10 BALB C       2B                   3.35 rep2      female     0.00187\n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nThis will sort the data frame by strain (according to alphabetical order, as it is a character column), and within each strain, they are then sorted by the amount of weight lost.\n\n\n\n\n\n\nPiping into View()\n\n\n\nIn the above example, we sorted the data by strain and then by weight lost, but because there are so many mice in each strain, the preview shown in our console doesn’t allow us to see the full effect of the sorting.\nOne handy trick you can use with pipes is to add View() at the end of your chain to open the data in a separate window. Try running this code, and you’ll be able to scroll through the full dataset to check that the other mouse strains have also been sorted correctly:\n\n# sort by strain first, then by weight lost\nmousezempic_dosage_data %&gt;%\n  arrange(mouse_strain, weight_lost_g) %&gt;%\n  View()\n\nThis is a great way to check that your code has actually done what you intended!\n\n\n\n2.2.1.1 Extracting rows with the smallest or largest values\nSlice functions are used to select rows based on their position in the data frame. The slice_min() and slice_max() functions are particularly useful, because they allow you to select the rows with the smallest or largest values in a particular column.\nThis is equivalent to using arrange() followed by head(), but is more concise:\n\n# get the 10 mice with the lowest drug dose\nmousezempic_dosage_data %&gt;%\n  # slice_min() requires the column to sort by, and n = the number of rows to keep\n  slice_min(drug_dose_g, n = 10)\n\n# A tibble: 13 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         3E                   3.15 rep1      female     0.00172\n 2 CD-1         3E                   3.4  rep1      female     0.00174\n 3 CD-1         1A                   3.45 rep3      female     0.00176\n 4 CD-1         2B                   3.25 rep1      female     0.00178\n 5 CD-1         2B                   3.9  rep1      male       0.00178\n 6 CD-1         2B                   2.9  rep2      female     0.00178\n 7 BALB C       2B                   3.25 rep1      female     0.00178\n 8 CD-1         2B                   2.98 rep1      &lt;NA&gt;       0.00179\n 9 CD-1         1A                   3.7  rep1      &lt;NA&gt;       0.0018 \n10 CD-1         3E                   3.6  rep1      male       0.0018 \n11 CD-1         3E                   3.8  rep1      male       0.0018 \n12 CD-1         3E                   3.95 rep1      male       0.0018 \n13 CD-1         2B                   3.55 rep1      female     0.0018 \n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n# get the top 5 mice that lost the most weight\nmousezempic_dosage_data %&gt;%\n  # slice_max() has the same arguments as slice_min()\n  slice_max(weight_lost_g, n = 5)\n\n# A tibble: 6 × 9\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n1 Black 6      3E                   6.3  rep1      male      0.00221\n2 Black 6      3E                   6.05 rep1      male      0.0023 \n3 Black 6      3E                   6    rep2      male      0.0022 \n4 Black 6      3E                   6    rep3      male      0.00222\n5 Black 6      3E                   5.95 rep2      male      0.00223\n6 Black 6      3E                   5.95 rep3      male      0.00229\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nBut wait— neither of those pieces of code actually gave the number of rows we asked for! In the first example, we asked for the 10 mice with the lowest drug dose, but we got 13. And in the second example, we asked for the top 5 mice that lost the most weight, but we got 6. Why aren’t the slice_ functions behaving as expected?\nIf we take a look at the help page (type ?slice_min in the console), we learn that slice_min() and slice_max() have an argument called with_ties that is set to TRUE by default. If we want to make sure we only get the number of rows we asked for, we would have to set it to FALSE, like so:\n\n# get the top 5 mice that lost the most weight\nmousezempic_dosage_data %&gt;%\n  # no ties allowed!\n  slice_max(weight_lost_g, n = 5, with_ties = FALSE)\n\n# A tibble: 5 × 9\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n1 Black 6      3E                   6.3  rep1      male      0.00221\n2 Black 6      3E                   6.05 rep1      male      0.0023 \n3 Black 6      3E                   6    rep2      male      0.0022 \n4 Black 6      3E                   6    rep3      male      0.00222\n5 Black 6      3E                   5.95 rep2      male      0.00223\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nThis is an important lesson: sometimes functions will behave in a way that is unexpected, and you might need to read their help page or use other guides/google/AI to understand why.\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. Which code would you use to sort the mousezempic_dosage_data data frame from biggest to smallest initial weight?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% sort(initial_weight_g)\n\n\n ✗mousezempic_dosage_data %&gt;% arrange(initial_weight_g)\n\n\n ✗mousezempic_dosage_data %&gt;% sort(descending(initial_weight_g))\n\n\n ✔mousezempic_dosage_data %&gt;% arrange(desc(initial_weight_g))\n\n\n\n\n\n\n2. Which code would you use to extract the 3 mice with the highest initial weight from the mousezempic_dosage_data data frame?\n\n\n\n\n ✔mousezempic_dosage_data %&gt;% slice_max(initial_weight_g, n = 3)\n\n\n ✗mousezempic_dosage_data %&gt;% arrange(desc(initial_weight_g))\n\n\n ✗mousezempic_dosage_data %&gt;% slice_min(initial_weight_g, n = 3)\n\n\n ✗mousezempic_dosage_data %&gt;% arrange(initial_weight_g)\n\n\n\n\n\n\n3. I’ve written the below code, but one of the comments is messing it up! Which one?\n\n# comment A\nmousezempic_dosage_data # comment B %&gt;%\n  # comment C\n  slice_max(weight_lost_g, n = 5, with_ties = FALSE) # comment D\n\n\n\n\n\n ✗Comment A\n\n\n ✔Comment B\n\n\n ✗Comment C\n\n\n ✗Comment D\n\n\n\n\n\n\n\nSolutions\n\n\nThe correct code to sort the mousezempic_dosage_data data frame from biggest to smallest initial weight is mousezempic_dosage_data %&gt;% arrange(desc(initial_weight_g)). The arrange() function is used to sort the data frame (although there is a sort() function in R, that’s not part of dplyr and won’t work the same way), and the desc() function is used to sort in descending order.\nThe correct code to extract the 3 mice with the highest initial weight from the mousezempic_dosage_data data frame is mousezempic_dosage_data %&gt;% slice_max(initial_weight_g, n = 3). The slice_max() function is used to select the rows with the largest values in the initial_weight_g column, and the n = 3 argument specifies that we want to keep 3 rows. The arrange() function is not needed in this case, because slice_max() will automatically sort the data frame by the specified column.\nThe comment that is messing up the code is Comment B. The # symbol is before the pipe operator %&gt;%, so R treats it as part of the comment and this breaks our chain of pipes. The other comments are fine, because they are either at the end of the line or on their own line. Basically, if a comment is changing the colour of the pipe operator (or any other bits of your code), it’s in the wrong place!\n\n\n\n\n\n\n\n2.2.2 Filtering data (rows)\n\n\n\nFilter allows you to filter rows using a logical test\n\n\nIn dplyr, the filter() function is used to subset rows based on their values. You provide a logical test, and filter() will keep the rows where the test is TRUE. We can write these tests using the comparison operators we learned in the previous session (e.g. ==, &lt; and !=, see Section 1.3).\nFor example, to filter the mousezempic_dosage_data data frame to only include mice that lost more than 6g:\n\nmousezempic_dosage_data %&gt;%\n  filter(weight_lost_g &gt; 6)\n\n# A tibble: 2 × 9\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n1 Black 6      3E                   6.3  rep1      male      0.00221\n2 Black 6      3E                   6.05 rep1      male      0.0023 \n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nOr to only include mice from cage 3E:\n\nmousezempic_dosage_data %&gt;%\n  # remember that == is used for testing equality\n  filter(cage_number == \"3E\") # don't forget the quotes either!\n\n# A tibble: 168 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         3E                   3.4  rep1      female     0.00174\n 2 CD-1         3E                   3.6  rep1      male       0.0018 \n 3 CD-1         3E                   3.8  rep1      female     0.00189\n 4 CD-1         3E                   3.95 rep1      male       0.00185\n 5 CD-1         3E                   3.8  rep1      male       0.0018 \n 6 CD-1         3E                   3.8  rep1      female     0.00187\n 7 CD-1         3E                   3.55 rep1      male       0.00183\n 8 CD-1         3E                   3.2  rep1      female     0.00187\n 9 CD-1         3E                   3.15 rep1      female     0.00172\n10 CD-1         3E                   3.95 rep1      male       0.0018 \n# ℹ 158 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\n\n2.2.2.1 Combining logical tests\nSometimes we want to filter based on multiple conditions. Here we will show some more advanced operators that can be used to combine logical tests.\nThe & operator is used to combine two logical tests with an ‘and’ condition. For example, to filter the data frame to only include mice that have a tail length greater than 19mm and are female:\n\nmousezempic_dosage_data %&gt;%\n  filter(tail_length_mm &gt; 19 & sex == \"female\")\n\n# A tibble: 5 × 9\n  mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n  &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n1 CD-1         1A                   3.45 rep1      female     0.00193\n2 CD-1         3E                   3.8  rep1      female     0.00189\n3 CD-1         2B                   3.3  rep1      female     0.00181\n4 CD-1         3E                   3.9  rep3      female     0.00191\n5 BALB C       2B                   3.52 rep3      female     0.00194\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nThe | operator is used to combine two logical tests with an ‘or’ condition. For example, to filter the data frame to only include mice that have an initial weight less than 35g or a tail length less than 14mm:\n\nmousezempic_dosage_data %&gt;%\n  filter(initial_weight_g &lt; 35 | tail_length_mm &lt; 14)\n\n# A tibble: 30 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n 2 CD-1         1A                   4.4  rep1      male       0.00198\n 3 CD-1         1A                   3.32 rep1      female     0.00184\n 4 CD-1         3E                   2.9  rep2      female     0.00187\n 5 CD-1         1A                   3.6  rep2      female     0.0019 \n 6 CD-1         1A                   3.2  rep2      female     0.00189\n 7 CD-1         2B                   3.4  rep2      female     0.00185\n 8 CD-1         2B                   2.9  rep2      female     0.00178\n 9 CD-1         2B                   3.05 rep3      female     0.00188\n10 Black 6      3E                   4.5  rep1      female     0.00211\n# ℹ 20 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nThe %in% operator can be used to filter based on a vector of multiple values (c(x, y)). It’s particularly useful when you have a few character values you want to filter on, as it is shorter to type than | (or).\nFor example, to filter the data frame to only include mice from cages 3E or 1A, we could use | like this:\n\nmousezempic_dosage_data %&gt;%\n  filter(cage_number == \"3E\" | cage_number == \"1A\")\n\n# A tibble: 220 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 210 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nOr we could use %in% like this:\n\nmousezempic_dosage_data %&gt;%\n  filter(cage_number %in% c(\"3E\", \"1A\"))\n\n# A tibble: 220 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 210 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. Which code would you use to filter the mousezempic_dosage_data data frame to only include mice from replicate 2?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% filter(replicate == 2)\n\n\n ✗mousezempic_dosage_data %&gt;% filter(replicate == rep2)\n\n\n ✔mousezempic_dosage_data %&gt;% filter(replicate == \"rep2\")\n\n\n ✗mousezempic_dosage_data %&gt;% filter(replicate = \"rep2\")\n\n\n\n\n\n\n2. What is NOT a valid way to filter the mousezempic_dosage_data data frame to only include mice that lost more than 4g, and have an initial weight less than 40g?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% filter(weight_lost_g &gt; 4) %&gt;% filter(initial_weight_g &lt; 40)\n\n\n ✔mousezempic_dosage_data %&gt;% filter(weight_lost_g &gt; 4) %&gt;% (initial_weight_g &lt; 40)\n\n\n ✗mousezempic_dosage_data %&gt;% filter(weight_lost_g &gt; 4 & initial_weight_g &lt; 40)\n\n\n ✗mousezempic_dosage_data %&gt;% filter(initial_weight_g &lt; 40) %&gt;% filter(weight_lost_g &gt; 4)\n\n\n\n\n\n\n3. Which option correctly describes what the following code is doing?\n\nmousezempic_dosage_data %&gt;%\n  filter(mouse_strain %in% c(\"BALB C\", \"Black 6\")) %&gt;%\n  filter(weight_lost_g &gt; 3 & weight_lost_g &lt; 5) %&gt;%\n  arrange(desc(drug_dose_g))\n\n\n\n\n\n ✗Filters the data frame to remove mice from the “BALB C” and “Black 6” strains, who only lost between 3 and 5g of weight, and then sorts the data frame by drug dose.\n\n\n ✗Filters the data frame to remove mice from the “BALB C” and “Black 6” strains, that lost between 3 and 5g of weight, and then sorts the data frame by drug dose in descending order.\n\n\n ✗Filters the data frame to only include mice from the “BALB C” and “Black 6” strains, that lost between 3 and 5g of weight, and then sorts the data frame by drug dose.\n\n\n ✔Filters the data frame to only include mice from the “BALB C” and “Black 6” strains, that lost between 3 and 5g of weight, and then sorts the data frame by drug dose in descending order.\n\n\n\n\n\n\n\nSolutions\n\n\nThe correct code to filter the mousezempic_dosage_data data frame to only include mice from replicate 2 is mousezempic_dosage_data %&gt;% filter(replicate == \"rep2\"). Option A is incorrect because 2 is not a value of replicate (when filtering you need to know what values are actually in your columns! So make sure to View() your data first). Option B is incorrect because the replicate column is a character column, so you need to use quotes around the value you are filtering on. Option D is incorrect because = is not the correct way to test for equality, you need to use ==.\nThe invalid option is mousezempic_dosage_data %&gt;% filter(weight_lost_g &gt; 4) %&gt;% (initial_weight_g &lt; 40). This is because the second filtering step is missing the name of the filter function, so R doesn’t know what to do with (initial_weight_g &lt; 40). The other options are valid ways to filter the data frame based on the specified conditions; note that we can use multiple filter() functions in a row to apply multiple conditions, or the & operator to combine them into a single filter() function. It’s just a matter of personal preference.\nThe correct description of the code is that it filters the data frame to only include mice from the “BALB C” and “Black 6” strains, then filters those further to only those that lost between 3 and 5g of weight, and finally sorts the data frame by drug dose in descending order.\n\n\n\n\n\n\n\n2.2.3 Dealing with missing values\nMissing values are a common problem in real-world datasets. In R, missing values are represented by NA. In fact, if you look at the mousezempic_dosage_data data frame we’ve been using, you’ll see that some of the cells contain NA: try spotting them with the View() function.\nYou can also find missing values in a data frame using the is.na() function in combination with filter(). For example, to find all the rows in the mousezempic_dosage_data data frame that have a missing value for the drug_dose_g column:\n\nmousezempic_dosage_data %&gt;%\n  filter(is.na(drug_dose_g))\n\n# A tibble: 2 × 9\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n1 CD-1         1A                     NA rep1      &lt;NA&gt;           NA\n2 Black 6      3E                     NA rep3      &lt;NA&gt;           NA\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nThe problem with missing values is that they can cause problems when you try to perform calculations on your data. For example, if you try to calculate the mean of a column that contains even a single missing value, the result will also be NA:\n\n# try to calculate the mean of the drug_dose_g column\n# remember from session 1 that we can use $ to access columns in a data frame\nmousezempic_dosage_data$drug_dose_g %&gt;% mean()\n\n[1] NA\n\n\nNA values in R are therefore referred to as ‘contagious’: if you put an NA in you usually get an NA out. If you think about it, that makes sense— when we don’t know the value of a particular mouse’s drug dose, how can we calculate the average? That missing value could be anything.\nFor this reason, it’s important to deal with missing values before performing calculations. Many functions in R will have an argument called na.rm that you can set to TRUE to remove missing values before performing the calculation. For example, to calculate the mean of the drug_dose_g column with the missing values excluded:\n\n# try to calculate the mean of the drug_dose_g column\n# remember from session 1 that we can use $ to access columns in a data frame\nmousezempic_dosage_data$drug_dose_g %&gt;% mean(na.rm = TRUE)\n\n[1] 0.002009152\n\n\nThis time, the result is a number, because the missing values have been removed before the calculation.\nBut not all functions have an na.rm argument. In these cases, you can remove rows with missing values. This can be done for a single column, using the filter() function together with is.na():\n\n# remove rows with missing values in the drug_dose_g column\nmousezempic_dosage_data %&gt;%\n  # remember the ! means 'not', it negates the result of is.na()\n  filter(!is.na(drug_dose_g))\n\n# A tibble: 342 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                   3.45 rep1      female     0.00193\n 5 CD-1         1A                   3.65 rep1      male       0.0019 \n 6 CD-1         1A                   3.62 rep1      female     0.00181\n 7 CD-1         1A                   4.68 rep1      male       0.00195\n 8 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n 9 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n10 CD-1         1A                   3.3  rep1      &lt;NA&gt;       0.00186\n# ℹ 332 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nOr, you can remove rows with missing values in any column using the na.omit() function:\n\n# remove rows with missing values in any column\nmousezempic_dosage_data %&gt;%\n  na.omit()\n\n# A tibble: 333 × 9\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                   3.45 rep1      female     0.00193\n 5 CD-1         1A                   3.65 rep1      male       0.0019 \n 6 CD-1         1A                   3.62 rep1      female     0.00181\n 7 CD-1         1A                   4.68 rep1      male       0.00195\n 8 CD-1         1A                   3.2  rep1      female     0.00182\n 9 CD-1         1A                   3.8  rep1      male       0.00191\n10 CD-1         1A                   4.4  rep1      male       0.00198\n# ℹ 323 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nSometimes, instead of removing rows with missing values, you might want to replace them with a specific value. This can be done using the replace_na() function from the tidyr package. replace_na() takes a list() which contains each of the column names you want to edit, and the value that should be used.\nFor example, to replace missing values in the weight_lost_g columns with 0, replace missing values in the sex column with ‘unknown’ and leave the rest of the data frame unchanged:\n\n# replace missing values in the drug_dose_g column with 0\nmousezempic_dosage_data %&gt;%\n  # here we need to provide the column_names = values_to_replace\n  # this needs to be contained within a list()\n  replace_na(list(weight_lost_g = 0, sex = \"unknown\"))\n\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex     drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male        0.00181\n 2 CD-1         1A                   3.8  rep1      female      0.00186\n 3 CD-1         1A                   3.25 rep1      female      0.00195\n 4 CD-1         1A                   0    rep1      unknown    NA      \n 5 CD-1         1A                   3.45 rep1      female      0.00193\n 6 CD-1         1A                   3.65 rep1      male        0.0019 \n 7 CD-1         1A                   3.62 rep1      female      0.00181\n 8 CD-1         1A                   4.68 rep1      male        0.00195\n 9 CD-1         1A                   3.48 rep1      unknown     0.00193\n10 CD-1         1A                   4.25 rep1      unknown     0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nWhen deciding how to handle missing values, you might have prior knowledge that NA should be replaced with a specific value, or you might decide that removing rows with NA is the best approach for your analysis.\nFor example, maybe we knew that the mice were given a weight_lost_g of NA if they didn’t lose any weight, it would then make sense to replace those with 0 (as we did in the code above). However, if the drug_dose_g column was missing simply because the data was lost, we might choose to remove those rows entirely.\nIt’s important to think carefully about how missing values should be handled in your analysis.\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What would be the result of running this R code: mean(c(1, 2, 4, NA))\n\n\n\n\n ✗2.333333\n\n\n ✗0\n\n\n ✔NA\n\n\n ✗An error\n\n\n\n\n\n\n2. Which line of code would you use to filter the mousezempic_dosage_data data frame to remove mice that have a missing value in the tail_length_mm column?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% filter(tail_length_mm != NA)\n\n\n ✗mousezempic_dosage_data %&gt;% filter(is.na(tail_length_mm))\n\n\n ✗mousezempic_dosage_data %&gt;% na.omit()\n\n\n ✔mousezempic_dosage_data %&gt;% filter(!is.na(tail_length_mm))\n\n\n\n\n\n\n3. How would you replace missing values in the initial_weight_g column with the value 35?\n\n\n\n\n ✔mousezempic_dosage_data %&gt;% replace_na(list(initial_weight_g = 35))\n\n\n ✗mousezempic_dosage_data %&gt;% replace_na(initial_weight_g = 35)\n\n\n ✗mousezempic_dosage_data %&gt;% replace_na(list(initial_weight_g == 35))\n\n\n ✗mousezempic_dosage_data %&gt;% replace_na(35)\n\n\n\n\n\n\n\nSolutions\n\n\n\nThe result of running the code mean(c(1, 2, 4, NA)) is NA. This is because the NA value is ‘contagious’, so when you try to calculate the mean of a vector that contains an NA, the result will also be NA. If we wanted to calculate the mean of the vector without the NA, we would need to use the na.rm = TRUE argument.\nThe correct line of code to filter the mousezempic_dosage_data data frame to remove mice that have a missing value in the tail_length_mm column is mousezempic_dosage_data %&gt;% filter(!is.na(tail_length_mm)). The ! symbol is used to negate the result of is.na(), so we are filtering to keep the rows where tail_length_mm is not NA. We can’t use the first option with the != NA because NA is a special value in R that represents missing data, and it can’t be compared to anything, and the third option is incorrect because na.omit() removes entire rows with missing values, rather than just filtering based on a single column.\nThe correct line of code to replace missing values in the initial_weight_g column with the value 35 is mousezempic_dosage_data %&gt;% replace_na(list(initial_weight_g = 35)). The replace_na() function takes a list() that contains the column names you want to replace and the values you want to replace them with. We only need to use a single equal sign here as we’re not testing for equality, we’re assigning a value.\n\n\n\n\n\n\n\n2.2.4 Selecting columns\n\n\n\nSelect allows you to select only certain columns\n\n\nWhile filter() is used to subset rows, select() is used to subset columns. You can use select() to keep only the columns you’re interested in, or to drop columns you don’t need.\nThe select() function takes the names of the columns that you want to keep/remove (no vector notation c() or quotation marks \"\" necessary). For example, to select only the mouse_strain, initial_weight_g, and weight_lost_g columns from the mousezempic_dosage_data data frame:\n\nmousezempic_dosage_data %&gt;%\n  select(mouse_strain, initial_weight_g, weight_lost_g)\n\n# A tibble: 344 × 3\n   mouse_strain initial_weight_g weight_lost_g\n   &lt;chr&gt;                   &lt;dbl&gt;         &lt;dbl&gt;\n 1 CD-1                     39.1          3.75\n 2 CD-1                     39.5          3.8 \n 3 CD-1                     40.3          3.25\n 4 CD-1                     NA           NA   \n 5 CD-1                     36.7          3.45\n 6 CD-1                     39.3          3.65\n 7 CD-1                     38.9          3.62\n 8 CD-1                     39.2          4.68\n 9 CD-1                     34.1          3.48\n10 CD-1                     42            4.25\n# ℹ 334 more rows\n\n\nWe can see that all the other columns have been removed from the data frame.\nIf you want to keep all columns except for a few, you can use - to drop columns. For example, to keep all columns except for cage_number and sex:\n\nmousezempic_dosage_data %&gt;%\n  select(-cage_number, -sex)\n\n# A tibble: 344 × 7\n   mouse_strain weight_lost_g replicate drug_dose_g tail_length_mm\n   &lt;chr&gt;                &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;          &lt;dbl&gt;\n 1 CD-1                  3.75 rep1          0.00181           18.7\n 2 CD-1                  3.8  rep1          0.00186           17.4\n 3 CD-1                  3.25 rep1          0.00195           18  \n 4 CD-1                 NA    rep1         NA                 NA  \n 5 CD-1                  3.45 rep1          0.00193           19.3\n 6 CD-1                  3.65 rep1          0.0019            20.6\n 7 CD-1                  3.62 rep1          0.00181           17.8\n 8 CD-1                  4.68 rep1          0.00195           19.6\n 9 CD-1                  3.48 rep1          0.00193           18.1\n10 CD-1                  4.25 rep1          0.0019            20.2\n# ℹ 334 more rows\n# ℹ 2 more variables: initial_weight_g &lt;dbl&gt;, id_num &lt;dbl&gt;\n\n\nThere are also some helper functions that can be used to select columns based on their names :\n\nThere are several helper functions that can be used with the select function\n\n\n\n\n\n\n\nFunction\nDescription\nExample\n\n\n\n\nstarts_with()\nselect column(s) that start with a certain string\nselect all columns starting with the letter i\nselect(starts_with(\"i\"))\n\n\nends_with()\nselect column(s) that end with a certain string\nselect all columns ending with _g\nselect(ends_with(\"_g\"))\n\n\ncontains()\nselect column(s) that contain a certain string\nselect all columns containing the word ‘weight’\nselect(contains(\"weight\"))\n\n\n\nYou need to use quotation marks around the arguments in these helper functions, as they aren’t full column names, just strings of characters.\nTry using these helper functions to select columns from the mousezempic_dosage_data data frame!\n\n\n\n\n\n\nReordering columns\n\n\n\n We can reorder columns using the relocate() function, which works similarly to select() (except it just moves columns around rather than dropping/keeping them). For example, to move the sex column to before the cage_number column:\n\nmousezempic_dosage_data %&gt;%\n  # first the name of the column to move, then where it should go\n  relocate(sex, .before = cage_number)\n\n# A tibble: 344 × 9\n   mouse_strain sex    cage_number weight_lost_g replicate drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;  &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 CD-1         male   1A                   3.75 rep1          0.00181\n 2 CD-1         female 1A                   3.8  rep1          0.00186\n 3 CD-1         female 1A                   3.25 rep1          0.00195\n 4 CD-1         &lt;NA&gt;   1A                  NA    rep1         NA      \n 5 CD-1         female 1A                   3.45 rep1          0.00193\n 6 CD-1         male   1A                   3.65 rep1          0.0019 \n 7 CD-1         female 1A                   3.62 rep1          0.00181\n 8 CD-1         male   1A                   4.68 rep1          0.00195\n 9 CD-1         &lt;NA&gt;   1A                   3.48 rep1          0.00193\n10 CD-1         &lt;NA&gt;   1A                   4.25 rep1          0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\nTwo useful helper functions here are the everything() and last_col() functions, which can be used to move columns to the start/end of the data frame.\n\n# move id_num to the front\nmousezempic_dosage_data %&gt;%\n  relocate(id_num, .before = everything()) # don't forget the brackets\n\n# A tibble: 344 × 9\n   id_num mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n    &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1      1 CD-1         1A                   3.75 rep1      male       0.00181\n 2      2 CD-1         1A                   3.8  rep1      female     0.00186\n 3      3 CD-1         1A                   3.25 rep1      female     0.00195\n 4      4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5      5 CD-1         1A                   3.45 rep1      female     0.00193\n 6      6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7      7 CD-1         1A                   3.62 rep1      female     0.00181\n 8      8 CD-1         1A                   4.68 rep1      male       0.00195\n 9      9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10     10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;\n\n# move mouse_strain to the end\nmousezempic_dosage_data %&gt;%\n  relocate(mouse_strain, .after = last_col())\n\n# A tibble: 344 × 9\n   cage_number weight_lost_g replicate sex    drug_dose_g tail_length_mm\n   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;          &lt;dbl&gt;\n 1 1A                   3.75 rep1      male       0.00181           18.7\n 2 1A                   3.8  rep1      female     0.00186           17.4\n 3 1A                   3.25 rep1      female     0.00195           18  \n 4 1A                  NA    rep1      &lt;NA&gt;      NA                 NA  \n 5 1A                   3.45 rep1      female     0.00193           19.3\n 6 1A                   3.65 rep1      male       0.0019            20.6\n 7 1A                   3.62 rep1      female     0.00181           17.8\n 8 1A                   4.68 rep1      male       0.00195           19.6\n 9 1A                   3.48 rep1      &lt;NA&gt;       0.00193           18.1\n10 1A                   4.25 rep1      &lt;NA&gt;       0.0019            20.2\n# ℹ 334 more rows\n# ℹ 3 more variables: initial_weight_g &lt;dbl&gt;, id_num &lt;dbl&gt;, mouse_strain &lt;chr&gt;\n\n\nRe-ordering columns isn’t necessary, but it makes it easier to see the data you’re most interested in within the console (since often not all of the columns will fit on the screen at once). For example, if we are doing a lot of computation on the initial_weight_g column, we’d probably like to have that near the start so we can easily check it.\n\n\nNote that the output of the select() function is a new data frame, even if you only select a single column:\n\n# select the mouse_strain column\nmousezempic_dosage_data %&gt;%\n  select(mouse_strain) %&gt;%\n  # recall from session 1 that class() tells us the type of an object\n  class()\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nSometimes, we instead want to get the values of a column as a vector.\n\n\n\nPull allows you to pull acolumn out of a data frame as a vector\n\n\nWe can do this by using the pull() function, which extracts a single column from a data frame as a vector:\n\n# get the mouse_strain column as a vector\nmousezempic_dosage_data %&gt;%\n  pull(mouse_strain) %&gt;%\n  class()\n\n[1] \"character\"\n\n\nWe can see that the class of the output is now a vector, rather than a data frame. This is important because some functions only accept vectors, not data frames, like mean() for example:\n\n# this will give an error\nmousezempic_dosage_data %&gt;% select(initial_weight_g) %&gt;% mean(na.rm = TRUE)\n\nWarning in mean.default(., na.rm = TRUE): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n\n# this will work\nmousezempic_dosage_data %&gt;% pull(initial_weight_g) %&gt;% mean(na.rm = TRUE)\n\n[1] 43.92193\n\n\nNote how both times we used na.rm = TRUE to remove missing values before calculating the mean.\nYou might remember that we used the $ operator in the previous session to extract a single column from a data frame, so why use pull() instead? The main reason is that pull() works within a chain of pipes, whereas $ doesn’t.\nFor example, let’s say we want to know the average initial weight of mice that lost at least 4g. We can do this by chaining filter() and pull() together:\n\nmousezempic_dosage_data %&gt;%\n  # filter to mice that lost at least 4g\n  filter(weight_lost_g &gt;= 4) %&gt;%\n  # get the initial_weight_g column as a vector\n  pull(initial_weight_g) %&gt;%\n  # calculate mean, removing NA values\n  mean(na.rm = TRUE)\n\n[1] 46.48023\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. Which line of code would NOT be a valid way to select the drug_dose_g, initial_weight_g, and weight_lost_g columns from the mousezempic_dosage_data data frame?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% select(drug_dose_g, initial_weight_g, weight_lost_g)\n\n\n ✔mousezempic_dosage_data %&gt;% select(contains(\"g\"))\n\n\n ✗mousezempic_dosage_data %&gt;% select(ends_with(\"_g\"))\n\n\n ✗mousezempic_dosage_data %&gt;% select(-cage_number, -tail_length_mm, -id_num, -mouse_strain, -sex, -replicate)\n\n\n\n\n\n\n2. How would I extract the initial_weight_g column from the mousezempic_dosage_data data frame as a vector?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% filter(initial_weight_g)\n\n\n ✗mousezempic_dosage_data %&gt;% $initial_weight_g\n\n\n ✗mousezempic_dosage_data %&gt;% select(initial_weight_g)\n\n\n ✔mousezempic_dosage_data %&gt;% pull(initial_weight_g)\n\n\n\n\n\n\n3. How would you move the sex column to the end of the mousezempic_dosage_data data frame?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% relocate(sex)\n\n\n ✗mousezempic_dosage_data %&gt;% relocate(sex, .after = last_col)\n\n\n ✔mousezempic_dosage_data %&gt;% relocate(sex, .after = last_col())\n\n\n ✗mousezempic_dosage_data %&gt;% reorder(sex, .after = last_col())\n\n\n\n\n\n\n\nSolutions\n\n\n\nThe line of code that would NOT be a valid way to select the drug_dose_g, initial_weight_g, and weight_lost_g columns from the mousezempic_dosage_data data frame is mousezempic_dosage_data %&gt;% select(contains(\"g\")). This line of code would select all columns that contain the letter ‘g’, which would include columns like cage_number and tail_length_mm. We need to specify either ends_with(\"g\") or contains(\"_g\") to only get those with _g at the end. The other options are valid ways to select the specified columns, although some are more efficient than others!\nThe correct way to extract the initial_weight_g column from the mousezempic_dosage_data data frame as a vector is mousezempic_dosage_data %&gt;% pull(initial_weight_g). The pull() function is used to extract a single column from a data frame as a vector. The other options are incorrect because filter() is used to subset rows, $ is not used in a pipe chain, and select() is outputs a data frame, not extract them as vectors.\nThe correct way to move the sex column to the end of the mousezempic_dosage_data data frame is using the relocate() function like this: mousezempic_dosage_data %&gt;% relocate(sex, .after = last_col()). The last_col() function is used to refer to the last column in the data frame. The other options are incorrect because reorder() is not a valid function, and you need to remember to include the brackets () when using last_col().\n\n\n\n\n\n\n\n2.2.5 Modifying data\nSo far, we’ve learned how to filter rows and select columns from a data frame. But what if we want to change the data itself? This is where the mutate() function comes in.\n\n\n\nMutate allows you to add new columns to a data frame\n\n\nThe mutate() function is used to add new columns to a data frame, or modify existing columns, often by performing some sort of calculation. For example, we can add a new column to mousezempic_dosage_data that contains the drug dose in mg (rather than g):\n\nmousezempic_dosage_data %&gt;%\n  # add a new column called drug_dose_mg\n  # convert drug_dose_g to mg by multiplying by 1000\n  mutate(drug_dose_mg = drug_dose_g * 1000) %&gt;%\n  # just select the drug dose columns so we can compare them\n  select(drug_dose_g, drug_dose_mg)\n\n# A tibble: 344 × 2\n   drug_dose_g drug_dose_mg\n         &lt;dbl&gt;        &lt;dbl&gt;\n 1     0.00181         1.81\n 2     0.00186         1.86\n 3     0.00195         1.95\n 4    NA              NA   \n 5     0.00193         1.93\n 6     0.0019          1.9 \n 7     0.00181         1.81\n 8     0.00195         1.95\n 9     0.00193         1.93\n10     0.0019          1.9 \n# ℹ 334 more rows\n\n\nYou can see that the drug_dose_mg column has been added to the data frame, and it contains, for each row, the value of the drug_dose_g column multiplied by 1000 (NA values are preserved).\nThese calculations can be as complex as you like, and involve multiple different columns. For example, to add a new column to the mousezempic_dosage_data data frame that calculates the weight lost as a percentage of the initial weight:\n\nmousezempic_dosage_data %&gt;%\n  # calculate the % of initial weight that was lost\n  mutate(weight_lost_percent = (weight_lost_g / initial_weight_g) * 100)\n\n# A tibble: 344 × 10\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 334 more rows\n# ℹ 4 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;, weight_lost_percent &lt;dbl&gt;\n\n\nA useful helper function for mutate() is the case_when() function, which allows you to create new columns based on multiple conditions. We do this with the notation case_when(condition1 ~ value1, condition2 ~ value2, ...).\nFor example, to add a new column to the mousezempic_dosage_data data frame that categorises the mice based on how much weight they lost:\n\nmousezempic_dosage_data %&gt;%\n  # create a new column called weight_loss_category\n  mutate(weight_loss_category = case_when(\n    weight_lost_g &lt; 4 ~ \"Low\", # separate conditions with a comma\n    weight_lost_g &lt;= 5 ~ \"Medium\",\n    weight_lost_g &gt; 5 ~ \"High\"\n  )) %&gt;%\n  select(weight_lost_g, weight_loss_category)\n\n# A tibble: 344 × 2\n   weight_lost_g weight_loss_category\n           &lt;dbl&gt; &lt;chr&gt;               \n 1          3.75 Low                 \n 2          3.8  Low                 \n 3          3.25 Low                 \n 4         NA    &lt;NA&gt;                \n 5          3.45 Low                 \n 6          3.65 Low                 \n 7          3.62 Low                 \n 8          4.68 Medium              \n 9          3.48 Low                 \n10          4.25 Medium              \n# ℹ 334 more rows\n\n\nNote that the conditions are evaluated in order, and the first condition that is TRUE is the one that is used. So if a mouse lost 4.5g, it case_when() would first test if it fits the ‘Low’ category (by checking if 4.5 is less than 4, which it isn’t), and then if it fits the ‘Medium’ category (by checking if 4.5 is less than or equal to 5). Since it is, the mouse would be categorised as ‘Medium’.\n\n\n\n\n\n\nFallback with default value(s)\n\n\n\nIn the above example, what would happen if a mouse lost -1g (gained weight)? It wouldn’t fit any of the conditions, so it would get an NA in the weight_loss_category column. Sometimes you might want this behaviour, but other times you would prefer to specify a ‘fallback’ category that will be assigned to everything that doesn’t fit in the other categories. You can do this by including a .default = argument at the end of the case_when() function. For example:\n\nmousezempic_dosage_data %&gt;%\n  # create a new column called weight_loss_category\n  mutate(weight_loss_category = case_when(\n    weight_lost_g &lt; 4 ~ \"Low\", # separate conditions with a comma\n    weight_lost_g &lt;= 5 ~ \"Medium\",\n    weight_lost_g &gt; 5 ~ \"High\",\n    .default = \"Unknown\"\n  )) %&gt;%\n  select(weight_lost_g, weight_loss_category)\n\n# A tibble: 344 × 2\n   weight_lost_g weight_loss_category\n           &lt;dbl&gt; &lt;chr&gt;               \n 1          3.75 Low                 \n 2          3.8  Low                 \n 3          3.25 Low                 \n 4         NA    Unknown             \n 5          3.45 Low                 \n 6          3.65 Low                 \n 7          3.62 Low                 \n 8          4.68 Medium              \n 9          3.48 Low                 \n10          4.25 Medium              \n# ℹ 334 more rows\n\n\nNotice how the NA value in the fourth row is now categorised as ‘Unknown’.\n\n\nOne final thing to note is that mutate() can be used to modify existing columns as well as add new ones. To do this, just use the name of the existing column as the ‘new’ one.\nFor example, let’s use mutate() together with case_when() to modify the sex column so that it uses M and F instead male and female:\n\nmousezempic_dosage_data %&gt;%\n  # modify sex column\n  mutate(sex = case_when(\n    sex == \"female\" ~ \"F\",\n    sex == \"male\" ~ \"M\",\n    # if neither, code it as 'X'\n    .default = \"X\"))\n\n# A tibble: 344 × 9\n   mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      M         0.00181\n 2 CD-1         1A                   3.8  rep1      F         0.00186\n 3 CD-1         1A                   3.25 rep1      F         0.00195\n 4 CD-1         1A                  NA    rep1      X        NA      \n 5 CD-1         1A                   3.45 rep1      F         0.00193\n 6 CD-1         1A                   3.65 rep1      M         0.0019 \n 7 CD-1         1A                   3.62 rep1      F         0.00181\n 8 CD-1         1A                   4.68 rep1      M         0.00195\n 9 CD-1         1A                   3.48 rep1      X         0.00193\n10 CD-1         1A                   4.25 rep1      X         0.0019 \n# ℹ 334 more rows\n# ℹ 3 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What line of code would you use to add a new column to the mousezempic_dosage_data data frame that converts the tail_length_mm column to cm?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% create(tail_length_cm = tail_length_mm / 10)\n\n\n ✗mousezempic_dosage_data %&gt;% mutate(tail_length_cm == tail_length_mm / 10)\n\n\n ✔mousezempic_dosage_data %&gt;% mutate(tail_length_cm = tail_length_mm / 10)\n\n\n ✗mousezempic_dosage_data %&gt;% tail_length_cm = tail_length_mm / 10\n\n\n\n\n\n\n2. Explain in words what the following code does:\n\nmousezempic_dosage_data %&gt;%\n  arrange(desc(weight_lost_g)) %&gt;%\n  mutate(weight_lost_rank = row_number())\n\nHint: the row_number() function returns the number of each row in the data frame (1 being the first row and so on).\n\n\n\n\n ✗Adds a new column to the data frame that ranks the mice based on how much weight they lost, with 1 being the mouse that lost the least weight.\n\n\n ✔Adds a new column to the data frame that ranks the mice based on how much weight they lost, with 1 being the mouse that lost the most weight.\n\n\n ✗Adds a new column to the data frame that ranks the mice\n\n\n ✗Does nothing, because the row_number() function has no arguments\n\n\n\n\n\n\n3. What is wrong with this R code?\n\nmousezempic_dosage_data %&gt;%\n  mutate(weight_lost_category = case_when(\n    weight_lost_g &lt; 4 ~ \"Low\"\n    weight_lost_g &lt;= 5 ~ \"Medium\"\n    weight_lost_g &gt; 5 ~ \"High\"\n  ))\n\nError: &lt;text&gt;:4:5: unexpected symbol\n3:     weight_lost_g &lt; 4 ~ \"Low\"\n4:     weight_lost_g\n       ^\n\n\n\n\n\n\n ✗You didn’t include a .default = condition at the end of the case_when() function to act as a fallback\n\n\n ✗You can’t use the case_when() function with the mutate() function\n\n\n ✗weight_lost_g is not a valid column name\n\n\n ✔You need to separate the conditions in the case_when() function with a comma\n\n\n\n\n\n\n4. Explain in words what the following code does:\n\nmousezempic_dosage_data %&gt;%\n  mutate(mouse_strain = case_when(\n    mouse_strain == \"Black 6\" ~ \"B6\",\n    .default = mouse_strain\n  ))\n\nHint: if you’re not sure, try running the code, but pipe it into View() so that you can take a good look at what’s happening in the mouse_strain column.\n\n\n\n\n ✗Renames the strains of all the mice to “B6”, regardless of their original strain\n\n\n ✗This code will produce an error\n\n\n ✗Adds a new column that categorises the mice based on their strain, so that any mice from the “Black 6” strain are now called “B6”, and all other strains are left unchanged.\n\n\n ✔Modifies the mouse_strain column so that any mice from the “Black 6” strain are now called “B6”, and all other strains are left unchanged.\n\n\n\n\n\n\n\nSolutions\n\n\n\nThe correct line of code to add a new column to the mousezempic_dosage_data data frame that converts the tail_length_mm column to cm is mousezempic_dosage_data %&gt;% mutate(tail_length_cm = tail_length_mm / 10).\nThe code mousezempic_dosage_data %&gt;% arrange(desc(weight_lost_g)) %&gt;% mutate(weight_lost_rank = row_number()) adds a new column to the data frame that ranks the mice based on how much weight they lost, with 1 being the mouse that lost the most weight. First, the arrange(desc(weight_lost_g)) function sorts the data frame by the weight_lost_g column in descending order, and then the mutate(weight_lost_rank = row_number()) function adds a new column that assigns a rank to each row based on its position (row number) in the sorted data frame.\nThe error is that the conditions in the case_when() function are not separated by commas. Each condition should be followed by a comma because these are like the arguments in a function. Remeber that it’s optional to include the .default = condition at the end of the case_when() function.\nThe code mousezempic_dosage_data %&gt;% mutate(mouse_strain = case_when(mouse_strain == \"Black 6\" ~ \"B6\", .default = mouse_strain)) modifies the mouse_strain column so that any mice from the “Black 6” strain are now called “B6”, and all other strains are left unchanged. As we are calling our column mouse_strain, no new column is being created (we are modifying the existing one) and the .default = mouse_strain condition acts as a fallback to keep the original values (that already exist in the mouse_strain column) for any rows that don’t match our first condition (strain being “Black 6”).\n\n\n\n\n\n\n\n2.2.6 Summarising data\n\n\n\nSummarise allows you to calculate summary statistics that collapse many rows into one\n\n\nThe summarise() (or summarize(), if you prefer US spelling) function is used to calculate summary statistics on your data. It takes similar arguments to mutate(), but instead of adding a new column to the data frame, it returns a new data frame with a single row and one column for each summary statistic you calculate.\nFor example, to calculate the mean weight lost by the mice in the mousezempic_dosage_data data frame:\n\nmousezempic_dosage_data %&gt;%\n  summarise(mean_weight_lost = mean(weight_lost_g, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  mean_weight_lost\n             &lt;dbl&gt;\n1             4.20\n\n\nWe can also calculate multiple summary statistics at once. For example, to calculate the mean, median, and standard deviation of the weight lost by the mice:\n\nmousezempic_dosage_data %&gt;%\n  summarise(\n    mean_weight_lost = mean(weight_lost_g, na.rm = TRUE),\n    median_weight_lost = median(weight_lost_g, na.rm = TRUE),\n    sd_weight_lost = sd(weight_lost_g, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 3\n  mean_weight_lost median_weight_lost sd_weight_lost\n             &lt;dbl&gt;              &lt;dbl&gt;          &lt;dbl&gt;\n1             4.20               4.05          0.802\n\n\nThe power of summarising data is really seen when combined with grouping, which we will cover in the next section.\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. Explain in words what the following code does:\n\nmousezempic_dosage_data %&gt;%\n  summarise(average_tail = mean(tail_length_mm, na.rm = TRUE),\n            min_tail = min(tail_length_mm, na.rm = TRUE),\n            max_tail = max(tail_length_mm, na.rm = TRUE))\n\n\n\n\n\n ✗Calculates the average, minimum, and maximum tail length of the mice in the mousezempic_dosage_data data frame.\n\n\n ✔Produces a data frame containing one column for each of the average, minimum, and maximum tail length of the mice in the mousezempic_dosage_data data frame.\n\n\n ✗Finds the average tail length of the mice in the mousezempic_dosage_data data frame.\n\n\n ✗Produces a vector containing the average, minimum, and maximum tail length of the mice in the mousezempic_dosage_data data frame.\n\n\n\n\n\n\n2. What is NOT a valid way to calculate the mean weight lost by the mice in the mousezempic_dosage_data data frame?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% summarise(mean_weight_lost = mean(weight_lost_g, na.rm = TRUE))\n\n\n ✗mousezempic_dosage_data %&gt;% pull(weight_lost_g) %&gt;% mean(na.rm = TRUE)\n\n\n ✗mousezempic_dosage_data %&gt;% summarize(mean_weight_lost = mean(weight_lost_g, na.rm = TRUE))\n\n\n ✔mousezempic_dosage_data %&gt;% mean(weight_lost_g, na.rm = TRUE)\n\n\n\n\n\n\n\nSolutions\n\n1. The code produces a data frame containing one column for each of the average, minimum, and maximum tail length of the mice in the mousezempic_dosage_data data frame.\n2. The line of code that is NOT a valid way to calculate the mean weight lost by the mice in the mousezempic_dosage_data data frame is mousezempic_dosage_data %&gt;% mean(weight_lost_g, na.rm = TRUE). This line of code is incorrect because the mean() function is being used directly on the data frame, rather than within a summarise() function. The other options are valid ways to calculate the mean weight lost by the mice in the mousezempic_dosage_data data frame (although note that the second option uses pull() to extract the weight_lost_g column as a vector before calculating the mean, so the mean value is stored in a vector rather than in a data frame).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#sec-grouping",
    "href": "session_2.html#sec-grouping",
    "title": "2  Session 2: Working with data",
    "section": "2.3 Grouping",
    "text": "2.3 Grouping\n\n\n\nUsing summarise with the .by option allows you to create separate summaries for different ‘groups’ of data\n\n\nGrouping is a powerful concept in in dplyr that allows you to perform operations on subsets of your data. For example, you might want to calculate the mean weight lost by mice in each cage, or find the mouse with the longest tail in each strain.\nWe can group data using the .by argument that exists in many dplyr functions, like summarise() and mutate(), and passing it the name(s) of column(s) to group by. For example, to calculate the mean weight lost by mice in each cage:\n\nmousezempic_dosage_data %&gt;%\n  summarise(\n    mean_weight_lost = mean(weight_lost_g, na.rm = TRUE),\n    # don't forget it's .by, not by!\n    .by = cage_number)\n\n# A tibble: 3 × 2\n  cage_number mean_weight_lost\n  &lt;chr&gt;                  &lt;dbl&gt;\n1 1A                      3.71\n2 3E                      4.72\n3 2B                      3.71\n\n\nLike when we first learned the summarise function above, we give our new column a name (mean_weight_lost), and then we assign its value to be the mean of the weight_lost_g column (with NAs removed). But this time, we also added the .by argument to specify the column we want to group by (cage_number, in this case). This will return a data frame with the mean weight lost by mice in each cage.\nGrouping is a powerful tool for exploring your data and can help you identify patterns that might not be obvious when looking at the data as a whole. For example, notice how this grouped summary reveals that mice in cage 3E lost more weight than those in the other two cages.\nIt’s also possible to group by multiple columns by passing a vector of column names to the .by argument. For example, to calculate the mean weight lost by mice in each cage and strain:\n\nmousezempic_dosage_data %&gt;%\n  summarise(mean_weight_lost = mean(weight_lost_g, na.rm = TRUE),\n  # group by both cage_number and mouse_strain\n    .by = c(cage_number, mouse_strain))\n\n# A tibble: 5 × 3\n  cage_number mouse_strain mean_weight_lost\n  &lt;chr&gt;       &lt;chr&gt;                   &lt;dbl&gt;\n1 1A          CD-1                     3.71\n2 3E          CD-1                     3.71\n3 2B          CD-1                     3.69\n4 3E          Black 6                  5.08\n5 2B          BALB C                   3.73\n\n\nOf course, mean() is not the only function that we can use within summarise(). We can use any function that takes a vector of values and returns a single value, like median(), sd(), or max(). We can also use multiple functions at once, by giving each column a name and specifying the function we want to use:\n\nmousezempic_dosage_data %&gt;%\n  summarise(\n    n = n(),\n    mean_weight_lost = mean(weight_lost_g, na.rm = TRUE),\n    median_weight_lost = median(weight_lost_g, na.rm = TRUE),\n    sd_weight_lost = sd(weight_lost_g, na.rm = TRUE),\n    max_weight_lost = max(weight_lost_g, na.rm = TRUE),\n    min_weight_lost = min(weight_lost_g, na.rm = TRUE),\n    .by = cage_number)\n\n# A tibble: 3 × 7\n  cage_number     n mean_weight_lost median_weight_lost sd_weight_lost\n  &lt;chr&gt;       &lt;int&gt;            &lt;dbl&gt;              &lt;dbl&gt;          &lt;dbl&gt;\n1 1A             52             3.71               3.7           0.445\n2 3E            168             4.72               4.78          0.783\n3 2B            124             3.71               3.69          0.417\n# ℹ 2 more variables: max_weight_lost &lt;dbl&gt;, min_weight_lost &lt;dbl&gt;\n\n\nHere, we also used the n() function to calculate the number of mice in each cage. This is a special helper function that works within summarise to count the number of rows in each group.\n\n\n\n\n\n\nTo .by or not to .by?\n\n\n\nIn the dplyr package, there are two ways to group data: using the .by argument within various functions (as we have covered so far), or using the group_by() function, then performing your operations and ungrouping with ungroup().\nFor example, we’ve seen above how to calculate the mean weight lost by mice in each cage using the .by argument:\n\nmousezempic_dosage_data %&gt;%\n  summarise(mean_weight_lost = mean(weight_lost_g, na.rm = TRUE), .by = cage_number)\n\n# A tibble: 3 × 2\n  cage_number mean_weight_lost\n  &lt;chr&gt;                  &lt;dbl&gt;\n1 1A                      3.71\n2 3E                      4.72\n3 2B                      3.71\n\n\nBut we can also do the same using group_by() and ungroup():\n\nmousezempic_dosage_data %&gt;%\n  group_by(cage_number) %&gt;%\n  summarise(mean_weight_lost = mean(weight_lost_g, na.rm = TRUE)) %&gt;%\n  ungroup()\n\n# A tibble: 3 × 2\n  cage_number mean_weight_lost\n  &lt;chr&gt;                  &lt;dbl&gt;\n1 1A                      3.71\n2 2B                      3.71\n3 3E                      4.72\n\n\nThe two methods are equivalent, but using the .by argument within functions can be more concise and easier to read. Still, it’s good to be aware of group_by() and ungroup() as they are widely used, particularly in older code.\n\n\nAlthough grouping is most often used with summarise(), it can be used with dplyr functions too. For example mutate() function can also be used with grouping to add new columns to the data frame based on group-specific calculations. Let’s say we wanted to calculate the Z-score (also known as the standard score) to standardise the weight lost by each mouse within each strain.\nAs a reminder, the formula for calculating the Z-score is \\(\\frac{x - \\mu}{\\sigma}\\), where \\(x\\) is the value (in our case the weight_lost_g column), \\(\\mu\\) is the mean, and \\(\\sigma\\) is the standard deviation.\nWe can calculate this for each mouse in each strain using the following code:\n\nmousezempic_dosage_data %&gt;%\n  # remove NAs before calculating the mean and SD\n  filter(!is.na(weight_lost_g)) %&gt;%\n  mutate(weight_lost_z = (weight_lost_g - mean(weight_lost_g)) / sd(weight_lost_g), .by = mouse_strain) %&gt;%\n  # select the relevant columns\n  select(mouse_strain, weight_lost_g, weight_lost_z)\n\n# A tibble: 342 × 3\n   mouse_strain weight_lost_g weight_lost_z\n   &lt;chr&gt;                &lt;dbl&gt;         &lt;dbl&gt;\n 1 CD-1                  3.75         0.108\n 2 CD-1                  3.8          0.217\n 3 CD-1                  3.25        -0.983\n 4 CD-1                  3.45        -0.547\n 5 CD-1                  3.65        -0.110\n 6 CD-1                  3.62        -0.165\n 7 CD-1                  4.68         2.12 \n 8 CD-1                  3.48        -0.492\n 9 CD-1                  4.25         1.20 \n10 CD-1                  3.3         -0.874\n# ℹ 332 more rows\n\n\nUnlike when we used .by with summarise(), we still get the same number of rows as the original data frame, but now we have a new column weight_lost_z that contains the Z-score for each mouse within each strain. This could be useful for identifying outliers or comparing the weight lost by each mouse to the average for its strain.\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. Which line of code would you use to calculate the median tail length of mice belonging to each strain in the mousezempic_dosage_data data frame?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% summarise(median_tail_length = median(tail_length_mm), .by = mouse_strain)\n\n\n ✔mousezempic_dosage_data %&gt;% summarise(median_tail_length = median(tail_length_mm, na.rm = TRUE), .by = mouse_strain)\n\n\n ✗mousezempic_dosage_data %&gt;% summarise(median_tail_length = median(tail_length_mm, na.rm = TRUE), by = mouse_strain)\n\n\n ✗mousezempic_dosage_data %&gt;% mutate(median_tail_length = median(tail_length_mm, na.rm = TRUE), .by = mouse_strain)\n\n\n\n\n\n\n2. Explain in words what the following code does:\n\nmousezempic_dosage_data %&gt;%\n  summarise(max_tail_len = max(tail_length_mm, na.rm = TRUE), .by = c(mouse_strain, replicate))\n\n\n\n\n\n ✗Calculates the maximum tail length of all mice for each strain in the mousezempic_dosage_data data frame\n\n\n ✗Calculates the maximum tail length of all mice for each replicate in the mousezempic_dosage_data data frame\n\n\n ✗Calculates the maximum tail length of all mice in the mousezempic_dosage_data data frame\n\n\n ✔Calculates the maximum tail length of mice in each unique combination of strain and replicate in the mousezempic_dosage_data data frame.\n\n\n\n\n\n\n3. I want to count how many male and how many female mice there are for each strain in the mousezempic_dosage_data data frame. Which line of code would I use?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% summarise(count = n(), .by = sex)\n\n\n ✗mousezempic_dosage_data %&gt;% summarise(count = n(), .by = mouse_strain)\n\n\n ✔mousezempic_dosage_data %&gt;% summarise(count = n(), .by = c(mouse_strain, sex))\n\n\n ✗mousezempic_dosage_data %&gt;% summarise(count = n(), .by = mouse_strain, sex)\n\n\n\n\n\n\n4. I want to find the proportion of weight lost by each mouse in each cage in the mousezempic_dosage_data data frame. Which line of code would I use?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% summarise(weight_lost_proportion = weight_lost_g / sum(weight_lost_g, na.rm = TRUE), .by = cage_number)\n\n\n ✔mousezempic_dosage_data %&gt;% mutate(weight_lost_proportion = weight_lost_g / sum(weight_lost_g, na.rm = TRUE), .by = cage_number)\n\n\n ✗mousezempic_dosage_data %&gt;% mutate(weight_lost_proportion = weight_lost_g / sum(weight_lost_g, na.rm = TRUE, .by = cage_number))\n\n\n ✗mousezempic_dosage_data %&gt;% mutate(weight_lost_proportion = weight_lost_g / sum(weight_lost_g, na.rm = TRUE))\n\n\n\n\n\n\n\nSolutions\n\n\n\nThe correct line of code to calculate the median tail length of mice belonging to each strain in the mousezempic_dosage_data data frame is mousezempic_dosage_data %&gt;% summarise(median_tail_length = median(tail_length_mm, na.rm = TRUE), .by = mouse_strain). Remember to use na.rm = TRUE to remove any missing values before calculating the median, and to use .by to specify the column to group by (not by). Seeing as we want to calculate the median (collapse down to a single value per group), we need to use summarise() rather than mutate().\nThe code mousezempic_dosage_data %&gt;% summarise(max_tail_len = max(tail_length_mm, na.rm = TRUE), .by = c(mouse_strain, replicate)) calculates the maximum tail length of mice in each unique combination of strain and replicate in the mousezempic_dosage_data data frame.\nThe correct line of code to count how many male and how many female mice there are for each strain in the mousezempic_dosage_data data frame is mousezempic_dosage_data %&gt;% summarise(count = n(), .by = c(mouse_strain, sex)). We need to group by both mouse_strain and sex to get the count for each unique combination of strain and sex. Don’t forget that we specify the column names as a vector when grouping by multiple columns.\nThe correct line of code to find the proportion of weight lost by each mouse in each cage in the mousezempic_dosage_data data frame is mousezempic_dosage_data %&gt;% mutate(weight_lost_proportion = weight_lost_g / sum(weight_lost_g, na.rm = TRUE), .by = cage_number). We use mutate() because we want a value for each mouse (each row in our data), rather than to collapse down to a single value for each group (cage number in this case). Be careful that you use the .by argument within the mutate() function call, not within the sum() function by mistake (this is what is wrong with the third option).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#sec-reshaping",
    "href": "session_2.html#sec-reshaping",
    "title": "2  Session 2: Working with data",
    "section": "2.4 Reshaping and combining data",
    "text": "2.4 Reshaping and combining data\nIn the previous section, we learned how to filter, select, mutate, and summarise data. These are the most common operations you’ll perform on your data, and all generally revolve around working with specific columns or rows of your data frame. But what if you need to change the structure of your entire data frame? Re-shaping (with pivot_ functions) and combining (with join functions) data are two more advanced operations that can help you do this.\n\n2.4.1 Reshaping data with pivot functions\nPivoting is a way to change the structure of your data frame by rotating it so that rows become columns and vice versa. This can be useful when you want to change the way your data is organised, for example, to make it easier to plot or analyse.\n\n\n\nPivot functions allow you to change the structure of your data frame\n\n\nThe pivot_longer() function is used to pivot data from wide to long format, and the pivot_wider() function is used to pivot data from long to wide format.\n\n2.4.1.1 Pivot wider\nA common use case for pivot_wider() is to make a contingency table, which shows the number of observations for each combination of two variables. This is often easier to read than the same information in long format.\nFor example, let’s say we want to create a table that shows how many mice there are of each strain, in each cage number. We can achieve this in a long format using summarise() as we learned in the previous section:\n\nmousezempic_dosage_data %&gt;%\n  summarise(\n    n_mice = n(),\n    .by = c(cage_number, mouse_strain))\n\n# A tibble: 5 × 3\n  cage_number mouse_strain n_mice\n  &lt;chr&gt;       &lt;chr&gt;         &lt;int&gt;\n1 1A          CD-1             52\n2 3E          CD-1             44\n3 2B          CD-1             56\n4 3E          Black 6         124\n5 2B          BALB C           68\n\n\nNotice how we have a row for each unique combination of cage_number and mouse_strain. Instead, we can use pivot_wider() to create a table where each row represents a unique cage_number and each column represents a unique mouse_strain.\nTo use a pivot_wider() you need to tell R two bits of information:\n\nWhat the new columns should be (with names_from)\nWhere the values in these columns should come from (with values_from).\n\nIn this case, we want the mouse strains to be our new columns (so names_from = mouse_strain), and the average weight lost to be the values in the table (values_from = n_mice). Putting it all together, here is the code to make our summary table:\n\nmousezempic_dosage_data %&gt;%\n  summarise(\n    n_mice = n(),\n    .by = c(cage_number, mouse_strain)) %&gt;%\n  pivot_wider(names_from = mouse_strain, values_from = n_mice)\n\n# A tibble: 3 × 4\n  cage_number `CD-1` `Black 6` `BALB C`\n  &lt;chr&gt;        &lt;int&gt;     &lt;int&gt;    &lt;int&gt;\n1 1A              52        NA       NA\n2 3E              44       124       NA\n3 2B              56        NA       68\n\n\nNotice how NA values are used where there is no data for a particular combination of cage_number and mouse_strain.\n\n\n2.4.1.2 Pivot longer\nWhile wide data can be easier to read, long data is often easier to work with. That’s because a lot of the tidyverse functions we’ve learned so far (like filter(), mutate(), and summarise()) work in a row-wise fashion, which is more natural with long data.\nTo demonstrate pivot_longer(), we will introduce a new data frame called mousezempic_expression_data. This data frame contains the expression levels of two genes (TH and PRLH) suspected to be upregulated in mice taking MouseZempic, as well as one housekeeping gene (HPRT1), all measured in triplicate. You can download it here:\n Download mousezempic_expression_data.tsv \nOr run the following code in your R console to download it:\n\ndownload.file(\"https://raw.githubusercontent.com/kzeglinski/new_wehi_r_course/refs/heads/main/data/mousezempic_expression_data.tsv\", \"data/mousezempic_expression_data.tsv\")\n\nOnce you’ve done that, read it into R (notice that it’s a .tsv file, so we need to use either read_tsv() or read_delim(), not read_csv())\n\n# read in the data\nmousezempic_expression_data &lt;- read_tsv(\"data/mousezempic_expression_data.tsv\")\n\nRows: 453 Columns: 11\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr  (1): group\ndbl (10): id_num, TH_rep1, TH_rep2, TH_rep3, PRLH_rep1, PRLH_rep2, PRLH_rep3...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# print it out\nmousezempic_expression_data\n\n# A tibble: 453 × 11\n   id_num TH_rep1 TH_rep2 TH_rep3 PRLH_rep1 PRLH_rep2 PRLH_rep3 HPRT1_rep1\n    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n 1      1   1431.   2737.   2036.      297.      428.      320.       741.\n 2      2   2699.   4180.   3860.      388.      680.      500.       843.\n 3      3   3596.   5194.   4128.      201.      346.      266.      1047.\n 4      4   2723.   4442.   3728.      317.      576.      478.       541.\n 5      5   2197.   3656.   2887.      114.      205.      173.       798.\n 6      6   2316.   3949.   3355.      242.      383.      305.       763.\n 7      7   1570.   2740.   2129.      294.      489.      427.       796.\n 8      8   2683.   4749.   3563.      231.      400.      309.       922.\n 9      9   3023.   5170.   3830.      289.      464.      390.       921.\n10     10   3254.   5980.   4250.      337.      583.      436.       740.\n# ℹ 443 more rows\n# ℹ 3 more variables: HPRT1_rep2 &lt;dbl&gt;, HPRT1_rep3 &lt;dbl&gt;, group &lt;chr&gt;\n\n\nAs you can see, the data is in wide format, with each row representing a different mouse (identified by its id_num) and each column representing a different measurement of a gene. To put this data into a long format (where each measurement is contained on a separate row), we can use pivot_longer(), specifying three arguments:\n\ncols: the columns to pivot from. You can use selection helpers like contains() or starts_with() to easily select multiple columns at once.\nnames_to: the name of a new column that will contain the old column names.\nvalues_to: the name of a new column that will contain the values from the old columns.\n\nIn this particular case here’s what the code would look like:\n\nmousezempic_expression_data %&gt;%\n  pivot_longer(cols = contains(\"_rep\"), names_to = \"measurement\", values_to = \"expression_level\")\n\n# A tibble: 4,077 × 4\n   id_num group     measurement expression_level\n    &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;                  &lt;dbl&gt;\n 1      1 treatment TH_rep1                1431.\n 2      1 treatment TH_rep2                2737.\n 3      1 treatment TH_rep3                2036.\n 4      1 treatment PRLH_rep1               297.\n 5      1 treatment PRLH_rep2               428.\n 6      1 treatment PRLH_rep3               320.\n 7      1 treatment HPRT1_rep1              741.\n 8      1 treatment HPRT1_rep2             1300.\n 9      1 treatment HPRT1_rep3              988.\n10      2 treatment TH_rep1                2699.\n# ℹ 4,067 more rows\n\n\nLet’s go through those three arguments:\n\ncols = contains(\"_rep\"): This tells R to pivot all columns that contain the string “_rep”. In this case, that’s the columns TH_rep1, TH_rep2, TH_rep3, PRLH_rep1, PRLH_rep2, PRLH_rep3, HPRT1_rep1, HPRT1_rep2, and HPRT1_rep3.\nnames_to = \"measurement\": This tells R to create a new column called ‘measurement’ that contains the names of the old columns. So, for example, the value of the ‘measurement’ column for the first row will be ‘TH_rep1’.\nvalues_to = \"expression_level\": This tells R to create a new column called ‘expression_level’ that contains the values from the old columns. So, for example, the value of the ‘expression_level’ column for the first row will be the value of the TH_rep1 column.\n\nAfter running this code, you’ll see that the data frame is now in long format, with each row representing a different measurement of a gene for a different mouse.\n\n\n\n\n\n\nPerplexed by pivoting?\n\n\n\nPivoting can be a bit tricky to get your head around! Often when you’re doing analysis, you’ll run into the problem of knowing that you need to pivot, but not knowing exactly what arguments to use. In these cases, it can be helpful to look at examples online, like those in the R for Data Science book, or to just experiment with different arguments until you get the result you want.\n\n\n\n\n\n2.4.2 Combining data with join functions\nAnother way you might need to change the structure of your data is by combining it with other data frames. This is where the join functions come in. There are many different types of joins in dplyr (which you can read about here if you’re interested), but the most useful one is the left_join() function.\n\n\n\nThe left_join() function allows you to combine two data frames\n\n\nleft_join() is used to combine two data frames based on a common column. It takes three arguments - the first data frame, the second data frame, and the common column to join on. The reason it’s called a ‘left join’ is because it keeps all the rows from the first data frame (the ‘left’ data frame), and only adds rows from the second data frame (the ‘right’ data frame) if they match the common column.\nFor example, we can join the mousezempic_dosage_data data frame with the mousezempic_expression_data data frame based on the id_num column, which is common to both data frames:\n\n# example of using it in a pipe\n# here mousezempic_dosage_data is the left data frame (first) data frame passed on by the pipe\nmousezempic_dosage_data %&gt;%\n  left_join(mousezempic_expression_data, by = \"id_num\")\n\n# A tibble: 344 × 19\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 334 more rows\n# ℹ 13 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;, TH_rep1 &lt;dbl&gt;, TH_rep2 &lt;dbl&gt;, TH_rep3 &lt;dbl&gt;, PRLH_rep1 &lt;dbl&gt;,\n#   PRLH_rep2 &lt;dbl&gt;, PRLH_rep3 &lt;dbl&gt;, HPRT1_rep1 &lt;dbl&gt;, HPRT1_rep2 &lt;dbl&gt;,\n#   HPRT1_rep3 &lt;dbl&gt;, group &lt;chr&gt;\n\n\nThis code will return a new data frame that contains all the columns from mousezempic_dosage_data and all the columns from mousezempic_expression_data, with the rows matched based on the id_num column. If there is no match for a particular id_num in the mousezempic_expression_data data frame, the columns from that data frame will be filled with NA. Rows that only appear in the mousezempic_expression_data data frame will not be included in the final data frame.\nWe can also use left_join() when our columns have different names (but contain the same value) using a named vector the format c(\"name1\" = \"name2\"), where ‘name1’ is the name of the column in the left/first data frame (the one being piped in) and ‘name2’ is the name of the corresponding column in the right/second data frame.\nFor example, if the id_num column in the mousezempic_dosage_data data frame was called mouse_id instead, we could still join the two data frames using the following code:\n\nmousezempic_dosage_data %&gt;%\n  # for the sake of this example, make a new column called mouse_id\n  mutate(mouse_id = id_num) %&gt;%\n  # join the two data frames where mouse_id in the first data frame matches id_num in the second data frame\n  left_join(mousezempic_expression_data, by = c(\"mouse_id\" = \"id_num\"))\n\n# A tibble: 344 × 20\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 334 more rows\n# ℹ 14 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;,\n#   id_num &lt;dbl&gt;, mouse_id &lt;dbl&gt;, TH_rep1 &lt;dbl&gt;, TH_rep2 &lt;dbl&gt;, TH_rep3 &lt;dbl&gt;,\n#   PRLH_rep1 &lt;dbl&gt;, PRLH_rep2 &lt;dbl&gt;, PRLH_rep3 &lt;dbl&gt;, HPRT1_rep1 &lt;dbl&gt;,\n#   HPRT1_rep2 &lt;dbl&gt;, HPRT1_rep3 &lt;dbl&gt;, group &lt;chr&gt;\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What does the following code do?\n\nmousezempic_dosage_data %&gt;%\n  summarise(\n    med_tail = median(tail_length_mm, na.rm = TRUE),\n    .by = c(mouse_strain, sex)) %&gt;%\n  pivot_wider(names_from = sex, values_from = med_tail)\n\n\n\n\n\n ✗Pivots data into a wide format where there is a column for each sex.\n\n\n ✔Calculates the median tail length for each unique combination of mouse_strain and sex in the mousezempic_dosage_data data frame, then pivots into a wide format where there is a column for each sex.\n\n\n ✗Calculates the median tail length for each unique combination of mouse_strain and sex in the mousezempic_dosage_data data frame, then pivots into a wide format where there is a column for each mouse strain.\n\n\n ✗It just gives an error\n\n\n\n\n\n2. I have run the following code to create a new column in the mousezempic_dosage_data data frame that gives the weight of the mice at the end of the experiment.\n\nmousezempic_dosage_data %&gt;%\n  # add a column for the weight at the end of the experiment\n  mutate(final_weight_g = initial_weight_g - weight_lost_g) %&gt;%\n  # select the relevant columns only\n  select(id_num, initial_weight_g, final_weight_g)\n\n# A tibble: 344 × 3\n   id_num initial_weight_g final_weight_g\n    &lt;dbl&gt;            &lt;dbl&gt;          &lt;dbl&gt;\n 1      1             39.1           35.4\n 2      2             39.5           35.7\n 3      3             40.3           37.0\n 4      4             NA             NA  \n 5      5             36.7           33.2\n 6      6             39.3           35.6\n 7      7             38.9           35.3\n 8      8             39.2           34.5\n 9      9             34.1           30.6\n10     10             42             37.8\n# ℹ 334 more rows\n\n\nWhich pivot function call would I use to take this data from a wide format (where there is a column for the final and initial weight) to a long format (where there is a row for each mouse and each weight measurement)?\n\n\npivot_longer(cols = c(initial_weight_g, final_weight_g), names_to = \"weight\", values_to = \"timepoint\")\n\n\npivot_longer(cols = c(id_num, final_weight_g), names_to = \"timepoint\", values_to = \"initial_weight_g\")\n\n\npivot_wider(names_from = initial_weight_g, values_from = final_weight_g)\n\n\npivot_longer(cols = c(initial_weight_g, final_weight_g), names_to = \"timepoint\", values_to = \"weight\")\n\n\n\n3. Which of the following is NOT a valid way to join the mousezempic_dosage_data data frame with the mousezempic_expression_data data frame based on the id_num column?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% left_join(mousezempic_expression_data, by = \"id_num\")\n\n\n ✗left_join(mousezempic_dosage_data, mousezempic_expression_data, by = \"id_num\")\n\n\n ✔mousezempic_dosage_data %&gt;% left_join(mousezempic_expression_data, .by = \"id_num\")\n\n\n ✗mousezempic_dosage_data %&gt;% left_join(mousezempic_expression_data, by = (\"id_num\" = \"id_num\"))\n\n\n\n\n\n\n\nSolutions\n\n1. The code first calculates the median tail length for each unique combination of mouse_strain and sex in the mousezempic_dosage_data data frame, then pivots the data into a wide format where there is a column for each sex in the dataset (because of the argument names_from = sex )\n2. The correct pivot function call to take the data from a wide format to a long format is pivot_longer(cols = c(initial_weight_g, final_weight_g), names_to = \"timepoint\", values_to = \"weight\"). This code tells R to pivot the initial_weight_g and final_weight_g columns into a long format, where there is a row for each mouse and each weight measurement. The names_to argument specifies to make a column called ‘timepoint’ that tells us whether the measurement is initial or final, and the values_to argument specifies the name of the new column that will contain these measurements.\n3. The line of code that is NOT a valid way to join the mousezempic_dosage_data data frame with the mousezempic_expression_data data frame based on the id_num column is mousezempic_dosage_data %&gt;% left_join(mousezempic_expression_data, .by = \"id_num\"). This line of code is incorrect because the .by argument is not used in the left_join() function (this can be confusing! it’s .by when grouping by by when joining). The other options are valid ways to join the two data frames based on the id_num column: remember that we don’t have to use pipes to join data frames, we can use the left_join() function directly, and we can use a named vector to specify the columns to join on (although here it’s a bit redundant as the columns have the same name).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#sec-saving",
    "href": "session_2.html#sec-saving",
    "title": "2  Session 2: Working with data",
    "section": "2.5 Saving data to a file",
    "text": "2.5 Saving data to a file\nOnce you’ve cleaned and transformed your data, you’ll often want to save it to a file so that you can use it in other programs or share it with others. The write_csv() and write_tsv() functions from the readr package are a great way to do this. They take two arguments - the data frame you want to save and the file path where you want to save it.\nFor example, let’s say I want to save my contingency table of the number of mice in each cage and strain to a CSV file called cage_strain_counts.csv:\n\n# create the contingency table\ncage_strain_counts &lt;- mousezempic_dosage_data %&gt;%\n  summarise(\n    n_mice = n(),\n    .by = c(cage_number, mouse_strain)) %&gt;%\n  pivot_wider(names_from = mouse_strain, values_from = n_mice)\n\n# save the data to a CSV file\nwrite_csv(cage_strain_counts, \"cage_strain_counts.csv\")\n\nCSV files are particularly great because they can be easily read into other software, like Excel.\nIt’s also possible to use the write_*() functions along with a pipe:\n\nmousezempic_dosage_data %&gt;%\n  summarise(\n    n_mice = n(),\n    .by = c(cage_number, mouse_strain)) %&gt;%\n  pivot_wider(names_from = mouse_strain, values_from = n_mice) %&gt;%\n  write_csv(\"cage_strain_counts.csv\")\n\nRemember here that the first argument (the data frame to save) is passed on by the pipe, so the only argument in the brackets is the second one: the file path.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#summary",
    "href": "session_2.html#summary",
    "title": "2  Session 2: Working with data",
    "section": "2.6 Summary",
    "text": "2.6 Summary\nHere’s what we’ve covered in this session:\n\nThe pipe operator %&gt;% and how we can use it to chain together multiple function calls, making our code more readable and easier to understand.\nThe basic dplyr verbs filter(), select(), mutate(), and arrange() and how they can be used to tidy and analyse data.\nMissing values (NA) and how to remove or replace them\nThe summarise() function and how it can be used to calculate summary statistics on your data, as well as the power of grouping data with the .by argument.\nReshaping data with pivot_longer() and pivot_wider() to change the structure of your data frame.\nCombining data with left_join() to merge two data frames based on a common column.\n\n\n\n\n\n\n\nWhy does data need to be tidy anyway?\n\n\n\nIn this session, we’ve been focusing on making our data ‘tidy’: that is, structured in a consistent way that makes it easy to work with. A nice visual illustration of tidy data and its importance can be found here.\n\n\n\n2.6.1 Practice questions\n\nWhat is the purpose of the pipe operator %&gt;%? Keeping this in mind, re-write the following code to use the pipe.\n\nround(mean(c(1, 2, 3, 4, 5)))\nprint(as.character(1 + 10))\n\nWhat would be the result of evaluating the following expressions? You don’t need to know these off the top of your head, use R to help! (Hint: some expressions might give an error. Try to think about why)\n\nmousezempic_dosage_data %&gt;% filter(weight_lost_g &gt; 10)\nmousezempic_dosage_data %&gt;% select(tail_length_mm, weight_lost_g)\nmousezempic_dosage_data %&gt;% mutate(weight_lost_kg = weight_lost_g / 1000)\nmousezempic_dosage_data %&gt;% arrange(tail_length_mm)\nmousezempic_dosage_data %&gt;% filter(initial_Weight_g &gt; 10) %&gt;% arrange(mouse_strain)\nmousezempic_dosage_data %&gt;% relocate(mouse_strain, .after = cage_number)\nmousezempic_dosage_data %&gt;% pull(weight_lost_g)\nmousezempic_dosage_data %&gt;% filter(!is.na(weight_lost_g))\nmousezempic_dosage_data %&gt;% replace_na(list(weight_lost_g = 0))\nmousezempic_dosage_data %&gt;% summarise(mean_weight_lost = mean(weight_lost_g, na.rm = TRUE))\nmousezempic_dosage_data %&gt;% summarise(mean_weight_lost = mean(weight_lost_g, na.rm = TRUE), .by = cage_number)\n\nWhat is a missing value in R? What are two ways to deal with missing values in a data frame?\nUsing the mousezempic_dosage_data data frame, write R code to:\n\nMake a data frame that shows the number of mice of each strain, in each replicate.\nPivot this data frame into a wide format to create a contingency table.\nPivot the wide data frame from (b) back into a long format.\n\nLet’s say I have two data frames, df1 and df2, that I want to join based a shared ‘key’ column, that is called ‘key’ in df1 and ‘item_key’ in df2. Write R code to join these two data frames using the left_join() function.\n\n\n\nSolutions\n\n\nThe pipe operator %&gt;% is used to chain together multiple function calls, passing the result of one function to the next. Here’s how you could re-write the code to use the pipe:\n\nc(1, 2, 3, 4, 5) %&gt;% mean() %&gt;% round()\nas.character(1 + 10) %&gt;% print()\n\nThe result of evaluating the expressions would be:\n\nA data frame containing only the rows where weight_lost_g is greater than 10.\nA data frame containing only the tail_length_mm and weight_lost_g columns.\nA data frame with an additional column weight_lost_kg that contains the weight lost in kilograms.\nA data frame sorted by tail_length_mm, in ascending order.\nAn error because initial_Weight_g is not a column in the data frame.\nA data frame with the mouse_strain column moved to be after the cage_number column.\nA vector containing the values of the weight_lost_g column.\nA data frame containing only the rows where weight_lost_g is not NA.\nA data frame with missing values in the weight_lost_g column replaced with 0.\nA data frame with the mean weight lost by all mice.\nA data frame with the mean weight lost by mice in each cage.\n\nA missing value in R is represented by NA. Two ways to deal with missing values in a data frame are to remove them using filter(!is.na(column_name)) or to replace them with a specific value using replace_na(list(column_name = value)).\nHere’s how you could write R code to achieve the tasks:\n\nmousezempic_dosage_data %&gt;% summarise(n_mice = n(), .by = c(mouse_strain, replicate))\nmousezempic_dosage_data %&gt;% summarise(n_mice = n(), .by = c(mouse_strain, replicate)) %&gt;% pivot_wider(names_from = replicate, values_from = n_mice)\nmousezempic_dosage_data %&gt;% summarise(n_mice = n(), .by = c(mouse_strain, replicate)) %&gt;% pivot_wider(names_from = replicate, values_from = n_mice) %&gt;% pivot_longer(cols = starts_with(\"rep\"), names_to = \"replicate\", values_to = \"n_mice\")\n\nTo join the two data frames you could use df1 %&gt;% left_join(df2, by = c(\"key\" = \"item_key\")) (with pipe) or left_join(df1, df2, by = c(\"key\" = \"item_key\")) (without pipe).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "further_reading.html",
    "href": "further_reading.html",
    "title": "Futher reading",
    "section": "",
    "text": "Useful references",
    "crumbs": [
      "Futher reading"
    ]
  },
  {
    "objectID": "further_reading.html#sec-useful-references",
    "href": "further_reading.html#sec-useful-references",
    "title": "Futher reading",
    "section": "",
    "text": "R for Data Science: this is a great online book that teaches you to do data science with R. Covering a wide range of topics using the tidyverse packages.\nThe R Gallery: this shows a range of plots that can be created in R using ggplot2 with associated code for each plot.\nR-bloggers: this is a blog that aggregates posts from a wide range of R bloggers. It is a great resource for finding out about new packages and techniques in R.\nDatacamp R documentation: this provides a reference to a lot of programming and data analysis in R using base R functionality.",
    "crumbs": [
      "Futher reading"
    ]
  },
  {
    "objectID": "further_reading.html#paths",
    "href": "further_reading.html#paths",
    "title": "Futher reading",
    "section": "Paths",
    "text": "Paths\nWe briefly touched on paths in the first session, but it is an important and complex topic that with worth digging into further. Paths are a way to specify the location of a file or directory on your computer, they are important whenever data needs to be read from or written to a file. This makes it a crucial concept for data analysis in R.\n\nAbsolute paths\nAn absolute path is defined as the full path from the root directory of the computer. These paths start with the root directory, which is / on Unix-based systems (like Linux and MacOS) and C:\\ on Windows systems. For example, the absolute path to the home directory on a Unix-based system would be /home/my_username/analysis/data/file.txt. These paths should be used when the location of the file is not going to change and is in some shared location external to the project.\n\n\nRelative paths\nRelative paths are defined as a path relative to the current working directory. If you are already in the directory /home/users/my_username/analysis/, the relative path to the file data/file.txt would be have the same meaning as the absolute path /home/users/my_username/analysis/data/file.txt. Relative paths are useful when the location of the file is likely to change, for example if the whole analysis folder might be moved around with its included data.\nUsers tend to have a home directory, which is the private directory each user is assigned. This directory is often located at /home/my_username/ on Unix-based systems and C:\\Users\\my_username\\ on Windows systems. This directory commonly acts as the starting point for many paths local to the user, and can be referred to using the shortcut ~ (tilde). For example, the path ~/analysis/data/file.txt would be equivalent to /home/my_username/analysis/data/file.txt on a Unix-based system. The exact path that is referred to by ~ can be found by running the command Sys.getenv(\"HOME\") in R, and is relative to the user running the R session.\n\n\nThe here package\nThere are situations where you want to organise your scripts into folders, if you navigate to these folders and run the scripts, they will run within the folder they are in. But often you will want to run the script from the root folder of the project. For example if you have a script in ~/analysis/scripts/plot.R and inside you use data/file.txt to reference ~/analysis/data/file.txt, if you run the script from ~/analysis/scripts/ it will not find the file. The here package solved this problem by anchoring your paths relative to the root folder of the project. Details about the package can be found here.",
    "crumbs": [
      "Futher reading"
    ]
  }
]