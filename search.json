[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "WEHI R Course",
    "section": "",
    "text": "Preface\nCode-based analysis is an increasingly important skill for modern biomedical research. The R coding language enables user-friendly data tidying and transformation, and creation of publication-ready graphics. R is also core to bioinformatics research, supporting all types of ’omics data analysis, and general statistical analysis too.\nDesigned for complete coding beginners, this course will introduce data wrangling, data visualisation, and bioinformatics analysis in R. The first 4 of 6 sessions will cover foundations of R, and user-friendly ‘tidyverse’ software, which is applicable to many areas of medical and clinical research, and beyond. The final two sessions will combine tidyverse and specialised bioinformatics software to perform an RNA seq analysis workflow.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-book",
    "href": "index.html#how-to-use-this-book",
    "title": "WEHI R Course",
    "section": "How to use this book",
    "text": "How to use this book\nThis course is divided into 6 sessions. In the first 3 sessions, we will cover the basics of R and the tidyverse, and in the last 3 sessions, we will apply these skills to a bioinformatics analysis (session 4 covers a more general analysis, while 5 & 6 focus on RNA-seq). Each session is divided into sections, which are designed to be completed in order. Each section contains a mix of text, code, and exercises.\nCode is shown in blue, with the output below it in grey, just like it would show up in the R console.\n\n# This is an R code block\n# You can run this code by copying it into the R console\n1 + 1\n\n[1] 2\n\n\nYou can run the code yourself by copying it (using the copy button in the top right of the code block) and pasting it into R on your computer.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setup",
    "section": "",
    "text": "Installing R and RStudio",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "setup.html#installing-r-and-rstudio",
    "href": "setup.html#installing-r-and-rstudio",
    "title": "Setup",
    "section": "",
    "text": "Using a non-WEHI computer\ncopy the instructions for installing R/RStudio and packages that kerry usually sends around and put them here",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "setup.html#sec-instPackages",
    "href": "setup.html#sec-instPackages",
    "title": "Setup",
    "section": "Installing packages",
    "text": "Installing packages",
    "crumbs": [
      "Setup"
    ]
  },
  {
    "objectID": "session_1.html",
    "href": "session_1.html",
    "title": "1  Session 1: Introduction to R",
    "section": "",
    "text": "1.1 Using RStudio\nIn this session, we will get familiar with R",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-usingRstudio",
    "href": "session_1.html#sec-usingRstudio",
    "title": "1  Session 1: Introduction to R",
    "section": "",
    "text": "1.1.1 What is R and RStudio?\nR is a free and popular statistical programming language, great for performing data analysis. RStudio is a free integrated development environment (IDE) which is a program that makes it easier for us to write code. During this course, we will learn how to use RStudio’s handy features like projects (which help us to keep track of different analyses) and the environment panel (which shows us all of our data/variables in one place).\n\n\n1.1.2 Creating a project\nProjects are a way we can organise our work in RStudio, so that we can resume where we left off and keep different analyses separate. Any time you start working on something new (like this course!) it is recommended that you start a new project. You can see the current project you’re working on, switch between projects or create a new project using the menu in the top right hand corner of RStudio:\n\n\n\nIn the top right hand corner of RStudio, you can see all of your projects\n\n\nTo begin this course, let’s make a new project. We’ll do this in a new directory (folder) so that everything stays organised:\n\n\n\nWe usually want to make a new project in its own directory (folder)\n\n\nNext, we need to tell R that we want to make a ‘New Project’ and not any of the other fancy things we could create:\n\n\n\nThere are many types of projects we can make in R, but for now we’ll stick with a regular project.\n\n\nFinally, we need to give our project an informative name:\n\n\n\nChoose a name that will help you remember what this project is about!\n\n\n\n\n\n\n\n\nName with underscores, not spaces\n\n\n\nYou’ll notice I named my project using an underscore (R_course) rather than a space (R course). In general, when coding we want to name things without spaces, so that it is clear to the computer that we are talking about a single entity (the ‘R_course’) as opposed to multiple things (‘R’ and ‘course’). We’ll revisit this idea later in the session in Section 1.4\n\n\n\n\n1.1.3 Creating an R script\nNow that our project is set up, we need to create a file to write our code in:\n\n\n\nHow to create a new R Script\n\n\nThis file is called an R Script. Don’t forget to save your R Script as you work so you don’t lose your progress! You can do this through the file menu or by using the keyboard shortcut Cmd-SCmd-S.\n\n\n1.1.4 Overview of the RStudio layout\nAt this point, your RStudio window should look like this, with four different panels visible:\n\n\n\nThe four panels of RStudio\n\n\nThis is what they’re used for:\n\nThe R Script panel. This is a text document where you can write code, and run it by highlighting the code or putting your cursor on that line, then pressing the ‘run’ button in the top-right corner or using the Cmd-EnterCmd-Enter keyboard shortcut.\nThe console. This is where the output (results) of your code will appear. You can also run code in the console, by typing it next to the &gt; symbol and pressing EnterEnter but it’s better to use the R Script, as the code you write there is saved and acts as a record of your work.\nThe environment panel. This is where the data and variables you use in your analysis will be listed. More on this later.\nThe files/plot/help panel.\n\nUnder the ‘files’ tab you can see the files in your current folder\nUnder the ‘plots’ tab you can view the plots you have created\nUnder the ‘help’ tab you can read manual pages to learn how to use functions\n\n\nAlthough there are other tabs for some of these panels, they are used for more niche things out of scope of this course.\n\n\n1.1.5 Writing our first piece of code\nNow we are ready to write our bit of code! We’ll start with one of the most important concepts in programming: comments. Comments are lines of our script that begin with # and they are ignored by the computer: they are just notes that we write to ourselves. It’s really important to write ‘well-commented’ code, with plenty of comments that clearly explain what your code is doing, so that your script can easily be understood by whoever looks at it next (whether this is someone else or you revisiting an analysis many months later!)\n\n\n\n\n\n\nDon’t forget your #\n\n\n\nIf you forget the # at the start of your comment, R will try to interpret your notes as actual code, and you’ll get an error message:\n\noops I forgot the hashtag\n\nError: &lt;text&gt;:1:6: unexpected symbol\n1: oops I\n         ^\n\n\n\n\nDuring this course, we will practice writing well-commented code, but here is an example of how we could write comments to explain the code for one plus one:\n\n# calculate one plus one\n1 + 1 # the + symbol means plus",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-maths",
    "href": "session_1.html#sec-maths",
    "title": "1  Session 1: Introduction to R",
    "section": "1.2 Practicing R code with maths",
    "text": "1.2 Practicing R code with maths\nTo practice running R code, let’s do some maths. Here’s how to code some basic mathematical operations in R:\n\n\n\n\n\n\n\n\nOperation\nCode\nExample\n\n\n\n\nBrackets\n()\nsixteen divided by the result of three minus one: 16 / (3 - 1)\n\n\nExponents\n^\nthree squared: 3 ^ 2\n\n\nDivision\n/\nten divided by 3: 10 / 3\n\n\nMultiplication\n*\neight times 4: 8 * 4\n\n\nAddition\n+\none plus one: 1 + 1\n\n\nSubtraction\n-\ntwo minus ten: 2 - 10\n\n\n\nLike in regular maths, R follows the order of operations. Here, the 3 + 2 in the brackets will be evaluated first, and then result will be multiplied by 7.\n\n# brackets evaluate first\n(3 + 2) * 7\n\n[1] 35\n\n\nYou might notice when running this code that before the output (result), there is a number one that looks like this: [1]. This relates to the length of our output, which here is just one single number (hence the 1). Later in the session we will write code with longer output, and the purpose of this number will become clearer, but you can ignore it for now.\n\n\n\n\n\n\nUsing whitespace in code\n\n\n\nAbove we used spaces between the numbers and mathematical operators in our code. R understands code without spaces too, but this makes it easier to read. Note that this is different to when we are naming things, when spaces are bad!\n\n# spaces don't matter in code\n3 ^ 2\n\n[1] 9\n\n# so both of these should give the same result\n3^2\n\n[1] 9\n\n\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. Which R expression would give me a result of 10?\n\n\n\n\n ✔(2 * 3) + (2 ^ 2)\n\n\n ✗(5 - 3) * 4\n\n\n ✗1 + 1\n\n\n ✗20 - 1\n\n\n\n\n\n\n2. What would be the result of running this line of R code: # test 1+1\n\n\n\n\n ✗1\n\n\n ✗2\n\n\n ✗An error\n\n\n ✔Nothing\n\n\n\n\n\n\n\nSolutions\n\n\n\n(2 * 3) + (2 ^ 2) is equal to 10. If you’re not sure, try copy-pasting this code into the console and running it! The best way to learn is by doing.\nThe code # test 1+1 is a comment, because it starts with a #. This means R ignores it: if you run this code, you won’t see any output in the console.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-comparisons",
    "href": "session_1.html#sec-comparisons",
    "title": "1  Session 1: Introduction to R",
    "section": "1.3 Comparisons",
    "text": "1.3 Comparisons\nR can perform comparisons, using the following notation:\n\n\n\nComparison\nCode\n\n\n\n\nEqual to\n==\n\n\nNot equal to\n!=\n\n\nGreater/less than\n&gt; or &lt;\n\n\nGreater/less than or equal to\n&gt;= or &lt;=\n\n\n\n\n\n\n\n\n\nMind your equal signs!\n\n\n\nBe careful to use double equal signs == when checking for equality. If you use only one, you’ll get an error:\n\n1 == 1 # this is TRUE\n\n[1] TRUE\n\n1 = 1 # this gives an error\n\nError in 1 = 1: invalid (do_set) left-hand side to assignment\n\n\n\n\nComparisons in R return either TRUE or FALSE:\n\n10 &gt; 10\n\n[1] FALSE\n\n10 &gt;= 10\n\n[1] TRUE\n\n\nYou can also negate the result of a comparison or any TRUE/FALSE value by using the ! operator before the expression.\n\n# gives FALSE (i.e. not TRUE)\n!TRUE\n\n[1] FALSE\n\n# gives TRUE: 1 is not equal to 2, but we've negated the result\n!(1 == 2)\n\n[1] TRUE\n\n\nThis is really useful for filtering data, which we will cover in Session 2\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What would be the result of running this R code: 10 &gt;= 10\n\n\n\n\n ✗10\n\n\n ✗FALSE\n\n\n ✔TRUE\n\n\n ✗An error\n\n\n\n\n\n\n2. Which of the following R expressions would give me a result of FALSE?\n\n\n\n\n ✗1 == 1\n\n\n ✗1 != (3 - 4) * 1\n\n\n ✗1 = 10\n\n\n ✔1 == 2\n\n\n\n\n\n\n3. What would be the result of running this R code: !TRUE\n\n\n\n\n ✔FALSE\n\n\n ✗TRUE\n\n\n ✗An error\n\n\n ✗Nothing\n\n\n\n\n\n\n\nSolutions\n\n\n\n10 &gt;= 10 is TRUE because 10 is equal to 10, and we are using the greater than or equal to operator, &gt;=.\n1 == 2 is the only expression that would give a result of FALSE. Be mindful that 1 = 10 is not a valid expression in R, and would give an error (since we need to use the double equal sign == for comparisons).\n!TRUE is FALSE because we are negating the value using !.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-variables",
    "href": "session_1.html#sec-variables",
    "title": "1  Session 1: Introduction to R",
    "section": "1.4 Variables",
    "text": "1.4 Variables\n\n1.4.1 What’s a variable?\nA variable (also known as an object) in R is like a label we can use to keep track of values. We assign (save) values to variables so that we can refer to them later.\nFor example, let’s say I use R to do some maths:\n\n(2 + 6) * 7\n\n[1] 56\n\n\nR outputs simply the result. To use this value later, I would need to assign the output to a variable.\nVariables are assigned with the assignment operator &lt;- (you can type this using the &lt;&lt; and -- keys, or use the shortcut alt-alt-).\n\n\n\n\n\n\nAssignment arrows\n\n\n\nYou might be familiar with assigning values to variables using the equal sign =, which is used in other programming languages and in maths. Although this does also work in R, it’s preferred to use the arrow &lt;- as this makes it really clear that a variable is being assigned. In this course we’ll be using &lt;-.\n\n\nReturning to our example, let’s save the result of the above calculation to a variable called my_number\n\n# assign the result to my_number\nmy_number &lt;- (2 + 6) * 7\n\nHere, R has performed the calculation to the right of the arrow ((2 + 6) * 7) and assigned the result of this to the my_number variable.\nYou’ll notice that this line of code doesn’t produce any output, because it has gone straight into our variable. If we want to know the value of my_number, we can either run it as a line of R code, like so:\n\nmy_number\n\n[1] 56\n\n\nOr, we can look at the environment panel in RStudio:\n\n\n\nWe can see our variables and their values in the environment panel\n\n\n\n\n1.4.2 Using variables in R code\nVariables can be used in place of values (e.g. numbers) in R code. For example, we can use the my_number variable in a calculation:\n\n# multiply my_number by 2\nmy_number * 2\n\n[1] 112\n\n\nAs the name suggests, variables can vary! We can assign a new value to a variable at any time:\n\n# change the value of my_number to 12\nmy_number &lt;- 12\nmy_number\n\n[1] 12\n\n\nBecause the right hand side of the arrow is evaluated first, you can also assign to a variable a calculation that involves itself:\n\n# add 5 to my_number\nmy_number &lt;- my_number + 5\nmy_number # value is now 17 since 12 + 5 = 17\n\n[1] 17\n\n\n\n\n\n\n\n\nCareful of cases!\n\n\n\nOne thing we need to be careful of when using variables is that R is case-sensitive. This means that MY_NUMBER is not the same as my_number:\n\n# create the my_number variable\nmy_number &lt;- (2 + 6) * 7\n\n# produces error because MY_NUMBER is not the same as my_number\nMY_NUMBER\n\nError in eval(expr, envir, enclos): object 'MY_NUMBER' not found\n\n\n\n\nThere’s not really any harm in keeping variables around, but if you would like to remove them you can use the rm() function like so:\n\n# assign a variable\nmy_variable &lt;- 10\n\n# remove it\nrm(my_variable) # put the variable name inside the brackets\n\nWe’ll cover functions in more detail in Section 1.5.\nIf you want to remove ALL the variables you’ve assigned and start fresh, you can use the broom button in the environment panel:\n\n\n\nThe broom button removes all your variables\n\n\nTry using the broom to clean up your environment after completing the practice exercises at the end of this section.\n\n\n1.4.3 Choosing good variable names\nWhen naming variables, we need to follow these rules:\n\n\n\n\n\n\n\nRule\nExamples\n\n\n\n\nVariable names can only contain letters, numbers and underscores\n✅ Allowed: my_number, ID_2\n❌ Not allowed: my_number!, price$\n\n\nVariable names can’t start with a number\n✅ Allowed: my_number_2\n❌ Not allowed: 2_my_number\n\n\nVariable names can’t contain spaces\n✅ Allowed: my_number\n❌ Not allowed: my number\n\n\n\nIf we try to create a variable that breaks these rules, R will give an error:\n\n# gives an error because we use a non-allowed character\npercentage% &lt;- 100\n\nError: &lt;text&gt;:2:11: unexpected input\n1: # gives an error because we use a non-allowed character\n2: percentage% &lt;- 100\n             ^\n\n\n\n# gives an error because we start with a number\n1place &lt;- 1\n\nError: &lt;text&gt;:2:2: unexpected symbol\n1: # gives an error because we start with a number\n2: 1place\n    ^\n\n\n\n# gives an error because we have a space\nmy age &lt;- 5\n\nError: &lt;text&gt;:2:4: unexpected symbol\n1: # gives an error because we have a space\n2: my age\n      ^\n\n\nRStudio will try to help you spot these mistakes in your script, by using underlining them in red:\n\n\n\nRStudio underlines errors in your code\n\n\nBeyond those three key rules, there are also some best practices we should try to keep in mind when naming our variables:\n\nTry not to use captial letters. Since R is case sensitive, Genes is a different variable to genes. It can be easy to forget to use a captial letter, so it’s generally better to avoid them if you can.\nUse descriptive names. It’s better to use a longer name that describes what the variable is for, rather than a short name that doesn’t give much information. For example, gene_counts is better than gc. You’ll thank yourself later when you come back to your code and can’t remember what gc stands for!\nAvoid using names that are already used in R. For example, mean is a function in R that calculates the average of a set of numbers. If you use mean as a variable name, this could lead to errors: how will R know if you are referring to the function mean or your variable mean?\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. How would I assign the value of 10 to a variable called my_variable?\n\n\n\n\n ✗10\n\n\n ✔my_variable &lt;- 10\n\n\n ✗my_variable = 10\n\n\n ✗my variable &lt;- 10\n\n\n\n\n\n\n2. I have assigned the value of 10 to a variable called my_variable as in Q1. What then would be the output from running this line of R code: my_variable + 5?\n\n\n\n\n ✗An error\n\n\n ✗Nothing\n\n\n ✗5\n\n\n ✔15\n\n\n\n\n\n\n3. I have assigned the value of 10 to a variable called my_variable as in Q1. If I run the code my_variable &lt;- my_variable + 10, what is the new value of my_variable?\n\n\n\n\n ✗10\n\n\n ✗25\n\n\n ✔20\n\n\n ✗my_variable\n\n\n\n\n\n\n4. Which of the following is a valid variable name?\n\n\n\n\n ✗10th_place\n\n\n ✗(n)_mice\n\n\n ✗disease status\n\n\n ✔expression_level\n\n\n\n\n\n\n\nSolutions\n\n\n\nmy_variable &lt;- 10 is the correct way to assign the value of 10 to a variable called my_variable. Remember the arrow &lt;- is used for assignment in R.\nThe output would be 15, since my_variable is 10 and we are adding 5 to it.\nThe new value of my_variable would be 20, since we are adding 10 to the current value of my_variable (which is 10). Note that even though we added 5 to my_variable earlier, this value is not saved anywhere (since we didn’t assign it), so we are starting from the original value of 10.\nexpression_level is the only valid variable name. 10th_place starts with a number, (n)_mice contains brackets, and disease status contains a space.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-functions",
    "href": "session_1.html#sec-functions",
    "title": "1  Session 1: Introduction to R",
    "section": "1.5 Functions",
    "text": "1.5 Functions\n\n1.5.1 Functions and arguments\nFunctions are programs that take inputs (also known as arguments) and produce outputs. They have a name, followed by round brackets () which contain the arguments.\nFor example, when we used the code rm(my_variable) earlier, the function rm() was taking the input (argument) my_variable and producing the output of deleting that variable.\nSome functions have multiple arguments, which are specified by separating them with commas. Arguments have a set order in which they can be given, or they can be referred to specifically by their name (using a equal sign = to provide a value).\nAs an example, the round() function rounds a number to a specified number of decimal places. The first argument is the number to be rounded, and the second argument is the number of decimal places to round to.\n\n# we'll use this decimal to demonstrate the round function\ndecimal &lt;- 3.14159\n\n# round to 3 decimal places\nround(decimal, digits = 3)\n\n[1] 3.142\n\n# we don't have to specify the argument name if we provide the arguments in the correct order\nround(decimal, 3)\n\n[1] 3.142\n\n\nWe can see that both of our calls to the round() function produced the same result, but the first is easier to understand since we explicitly specified the argument.\nMany arguments have default values so you don’t need to specify every argument for every function. For example, the round() function has a default value of 0 for the digits argument, so if you don’t specify it, the number will be rounded to the nearest whole number.\n\nround(decimal)\n\n[1] 3\n\n\n\n\n\n\n\n\nCommon errors with functions\n\n\n\nHere are some common errors you might encounter when using functions. Have a look at the code below and read the error messages to see how the two relate. This will help you to fix typos/errors in your own code.\n\n# forgot to enclose the arguments in brackets\nround 3.14159\n\nError: &lt;text&gt;:2:7: unexpected numeric constant\n1: # forgot to enclose the arguments in brackets\n2: round 3.14159\n         ^\n\n\n\n# forgot the comma between the arguments\nround(3.14159 digits = 3)\n\nError: &lt;text&gt;:2:15: unexpected symbol\n1: # forgot the comma between the arguments\n2: round(3.14159 digits\n                 ^\n\n\n\n# spelt the argument name wrong\nround(3.14159, digts = 3)\n\nError in round(3.14159, digts = 3): unused argument (digts = 3)\n\n\n\n# forgot to close the brackets\nround(3.14159, digits = 3\n\nError: &lt;text&gt;:3:0: unexpected end of input\n1: # forgot to close the brackets\n2: round(3.14159, digits = 3\n  ^\n\n\nRStudio will also flag some of these sorts of issues in the script panel, although it won’t catch everything:\n\n\n\nRStudio can help you to find errors in your function calls before you run the code\n\n\n\n\n\n\n1.5.2 Getting help with functions: within R\nWhen you’re using a function, you might not know what arguments it takes, what they do or what their default values are. Nobody can remember all of this information, so one of the most important skills in programming is learning how to access help.\nYou can access the help pages for a function by typing ? followed by the name of the function:\n\n?round\n\nOr searching for the function in the help tab in RStudio:\n\n\n\nYou can search for functions directly in the help panel\n\n\nHere’s what the help page looks like for the round function:\n\n\n\nThe help page for the round function\n\n\nHelp pages can sometimes be quite technical or complicated– for example the help page for round also describes various other similar functions for rounding numbers. Often the most important section to look at is the ‘arguments’ one:\n\n\n\nHelp pages have a section for describing arguments\n\n\nYou can also see help for functions in the script panel, as you are typing your code:\n\n\n\nRStudio will show you a preview of the help page as you type a function name\n\n\nIt will also suggest you the names of arguments:\n\n\n\nRStudio also suggests arguments for functions as you type\n\n\nSo, if you get stuck with how to use a function, wait a moment and see if RStudio will suggest what you need.\n\n\n1.5.3 Getting help with functions: beyond R\nSometimes, the R help pages can be pretty tricky to understand, and they can’t help you if you don’t know the name of the function you need! In this course, we’ll learn about lots of different functions, but even R experts need to look things up sometimes. Here are some good resources for getting help:\n\nGoogle. R is a pretty popular language, so if you google ‘how to do x in R’, you’ll probably find an answer\nChatGPT (or similar). AI tools can be really useful in helping you write code, although make sure you double-check the results because it can make mistakes\nAsk others! There are lots of R users, and working together is often the best way to solve problems. This could be through online forums, like StackOverflow or in-person\n\nNo matter where you get your help, try to make sure you understand the code you find. Reading the help pages for new functions, or asking an AI like ChatGPT to explain what code is doing is a great way to expand your R knowledge.\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What would be the result of running this R code: round(3.14159, digits = 2)\n\n\n\n\n ✗3.14159\n\n\n ✗3.141\n\n\n ✔3.14\n\n\n ✗3\n\n\n\n\n\n2. Look up the help pages for the following functions, and describe what they do:\n\nmean()\nSys.Date()\nsin()\n\n\n3. What is wrong with this line of R code: round(3.14159, digits = 3\n\n\n\n\n ✗Digits is not a valid argument for the round function\n\n\n ✗You need to use a double equal sign == for the digits argument\n\n\n ✗You don’t need to specify the digits argument\n\n\n ✔You need to close the brackets at the end of the line\n\n\n\n\n\n\n4. Which of the following lines of R code will run without error?\n\n\n\n\n ✗rm(my_variable\n\n\n ✗round(3.14159, Digits = 3)\n\n\n ✗round(3.14159 digits = 3)\n\n\n ✔round(3.14159, 3)\n\n\n\n\n\n\n\nSolutions\n\n\n\nThe result of running round(3.14159, digits = 2) would be 3.14. Remember the round() function rounds the number 3.14159 to 2 decimal places, according to the digits argument.\nThe mean() function calculates the average of a set of numbers, Sys.Date() returns the current date, and sin() calculates the sine of an angle (in radians).\nThe line of R code round(3.14159, digits = 3 is missing a closing bracket at the end, which is why it would produce an error.\nThe line of R code round(3.14159, 3) will run without error. The other lines of code have errors: rm(my_variable is missing a closing bracket, round(3.14159, Digits = 3) has a typo in the argument name (argument names are case sensitive), and round(3.14159 digits = 3) is missing a comma between the arguments. Remember that we don’t always need to specify the argument names if we provide the arguments in the correct order, which is why we could omit the digits = part in the correct line of code.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-dataTypes",
    "href": "session_1.html#sec-dataTypes",
    "title": "1  Session 1: Introduction to R",
    "section": "1.6 Data types",
    "text": "1.6 Data types\nEvery variable in R has a ‘type’. The type tells R what kind of data it is and consequently what it can and can’t do with the data. For example, it makes sense to perform mathematical functions like multiplication or division on numbers but not on words.\nThere are three basic types of data in R:\n\n\n\n\n\n\n\n\nType\nDescription\nExamples\n\n\n\n\nlogical\nalso known as ‘boolean’, true or false\nTRUE\nFALSE\n\n\nnumeric\nnumbers\n1\n0.523\n10000\n\n\ncharacter\ntext/numbers surrounded by quotation marks (double \"\" or single ''). Also known as a ‘string’\n'hello'\n\"cat\"\n\"my name is...\"\n\n\n\nThese are called ‘atomic’ data types as they are the most basic types of data from which other data types derive.\nYou can find the type of something using the class() function:\n\nclass(TRUE)\n\n[1] \"logical\"\n\nclass(1)\n\n[1] \"numeric\"\n\n# whatever you put in quotation marks is always a character\nclass(\"hello\")\n\n[1] \"character\"\n\nclass(\"TRUE\")\n\n[1] \"character\"\n\nclass(\"123\")\n\n[1] \"character\"\n\n\nIt is important to know the type of your data because, as mentioned earlier, R will not let you perform certain operations on data of the wrong type. For example, you can’t add two characters together:\n\n# this works\n1 + 1\n\n[1] 2\n\n# but this gives an error\n\"1\" + \"1\"\n\nError in \"1\" + \"1\": non-numeric argument to binary operator\n\n\nNor can you use the logical operator ! on a character:\n\n# this works\n!TRUE\n\n[1] FALSE\n\n# but this gives an error\n!\"TRUE\"\n\nError in !\"TRUE\": invalid argument type\n\n\nYou’ll notice that the error messages for these two examples explain that R can’t perform the operation you’re asking it to do on that data type.\nIf you want to change the type of a piece of data, you can use the as.x() functions like (e.g.as.logical(), as.numeric(), and as.character()):\n\n# convert a number to a character\nas.character(100)\n\n[1] \"100\"\n\n# convert a character to a number\nas.numeric(\"100\")\n\n[1] 100\n\n\nOf course, it doesn’t make sense to make some conversions. In the example below, we can’t convert the word “hello” to a number, so we get an NA:\n\n# if a conversion is not possible, you'll get an NA\nas.numeric(\"hello\")\n\nWarning: NAs introduced by coercion\n\n\n[1] NA\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What are the three atomic data types in R?\n\n\n\n\n ✔logical, numeric, character\n\n\n ✗integer, float, string\n\n\n ✗dataset, vector, matrix\n\n\n ✗boolean, text, number\n\n\n\n\n\n\n2. How do you find the type of a piece of data in R?\n\n\n\n\n ✗You can’t\n\n\n ✗Using the type() function\n\n\n ✗Guess\n\n\n ✔Using the class() function\n\n\n\n\n\n\n3. How would you convert the character “TRUE” to a logical?\n\n\n\n\n ✗TRUE\n\n\n ✔as.logical(\"TRUE\")\n\n\n ✗You can’t convert a character to a logical\n\n\n ✗Using the logical() function\n\n\n\n\n\n4. What are the types of the following?\n\n11\n\"eleven\"\nTRUE\n!FALSE\n0.49826\n\"-0.53\"\nas.numeric(\"11\")\n\n\n\nSolutions\n\n\n\nThe three atomic data types in R are logical, numeric, and character.\nYou can find the type of a piece of data in R using the class() function.\nTo convert the character “TRUE” to a logical, you would use as.logical(\"TRUE\") (we always use ‘as…’ functions to convert between types).\nThe types are:\n\n11 is numeric\n\"eleven\" is character\nTRUE is logical\n!FALSE is logical\n0.49826 is numeric\n\"-0.53\" is character (even though it looks like a number, it is surrounded by quotation marks so it is a character)\nas.numeric(\"11\") is numeric (since we converted the character “11” to a number with the as.numeric() function)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-datastructures",
    "href": "session_1.html#sec-datastructures",
    "title": "1  Session 1: Introduction to R",
    "section": "1.7 Data structures",
    "text": "1.7 Data structures\nBeyond the atomic data types, R has more complex data structures that can store multiple values. These are the building blocks of data analysis in R. The most common data structures are vectors, matrices, and data frames.\nThis figure summarises their key differences:\n\n\n\nOverview of the three main data structures in R. 📷 credit: https://bookdown.org/introrbook/intro2r/\n\n\n\n1.7.1 Vectors\nA vector is a collection of values of the same atomic type. Values in a vector are laid out linearly, one after another.\nYou can create vectors with the c() function, like so:\n\n# a vector of numbers\nc(1, 2, 3)\n\n[1] 1 2 3\n\n# a vector of characters\nc(\"a\", \"vector\", \"of\", \"characters\")\n\n[1] \"a\"          \"vector\"     \"of\"         \"characters\"\n\n# a vector of logicals\nc(TRUE, FALSE, TRUE)\n\n[1]  TRUE FALSE  TRUE\n\n\nFun fact: the ‘c’ in c() stands for ‘combine’.\nThere are a few ways to see the contents of a vector. You can simply type the name of the vector into the console, which will print out the whole thing:\n\n# in these examples we will use the letters vector that is\n# pre-loaded in R. It contains the alphabet in lowercase\nletters\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\nYou’ll notice that, in addition to the [1] that we usually see printed next to the output, there is also a [20]. This number is telling us where we are up to in the vector (so [1] means that line of output starts with the first element, \"a\" and [20] means that line of output starts with the 20th element of the vector, \"t\").\nBut what if we don’t always want to print the whole thing? For long vectors, it’s handy to use the head() and tail() functions to inspect just a few values. By default, these print the first and last 6 elements of a vector (you can change that by setting the n argument).\n\n# use head() and tail() to take a quick look\nhead(letters)\n\n[1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\"\n\ntail(letters)\n\n[1] \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\nYou can also use functions to look at other features of a vector, like its type (using the class() function just as for single values) or its length (using the length() function):\n\n# find the class of a vector\nclass(letters)\n\n[1] \"character\"\n\n# find the length of a vector\nlength(letters)\n\n[1] 26\n\n\nJust like you can with single values, vectors can be assigned to variables:\n\npet_names &lt;- c(\"sprinkle\", \"lucky\", \"coco\")\n\nThese variables will show up in the ‘Environment’ tab in RStudio:\n\n\n\nThe environment panel shows vectors too\n\n\nYou’ll notice vector variables are displayed a little differently to those with single values. The type (chr, for character) is displayed first, followed by [1:3] which tells you that the pet_names vector has elements from 1 to 3 (in other words, it has a length of 3). This is particularly helpful when part of the vector is cut off, like in this picture!\n\n\n\n\n\n\nColon (:) notation for vectors\n\n\n\nIn programming, the colon : is typically used to create sequences of numbers. You can use it to create a sequence of numbers from a starting point to an ending point.\nFor example, 1:5 creates a vector of numbers from 1 to 5:\n\n1:5\n\n[1] 1 2 3 4 5\n\n\n\n\nR is a vectorised language, which means that many functions and operations (like *, + etc) work directly on vectors without you having to write extra code. For example, we can use the mean() function to calculate the average of a vector of numbers:\n\n# create a vector of numbers\nnumbers &lt;- c(1, 2, 3, 4, 5)\n\n# calculate the mean\nmean(numbers)\n\n[1] 3\n\n\nBecause the other data structures we’ll cover are built on vectors, this concept will be useful for them as well.\n\n\n1.7.2 Matrices\nA matrix is the two-dimensional extension of the vector– it stores a collection of values of the same type that are laid out in a grid with rows and columns. An example of this is a gene count matrices where each row represents a gene, each column represents a sample and therefore each cell represents the count for a particular gene in a particular sample.\nYou can create a matrix using the matrix() function. The first argument is the vector of values to be put into the matrix, and the nrow and ncol arguments specify the number of rows and columns in the matrix:\n\n# create a 2x2 matrix and assign it to gene_counts\ngene_counts &lt;- matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2)\n\n# print the matrix\ngene_counts\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\nUsually though you would read in a matrix from a file (e.g. the gene count matrix from a sequencing experiment).\nMatrices are their own type of object in R:\n\nclass(gene_counts)\n\n[1] \"matrix\" \"array\" \n\n\nAnd they show up in the environment panel in RStudio under ‘Data’: \nThe rows and columns are usually labelled with names, although these names are considered metadata rather than being a part of the matrix. You can set them by assigning vectors of names to the rownames() and colnames() functions:\n\n# set row and column names\nrownames(gene_counts) &lt;- c(\"gene1\", \"gene2\")\ncolnames(gene_counts) &lt;- c(\"sample1\", \"sample2\")\n\n# print the matrix, now with names!\ngene_counts\n\n      sample1 sample2\ngene1       1       3\ngene2       2       4\n\n\n\n\n1.7.3 Data frames\nData frames are similar to matrices in that they store data in rows and columns. The difference is each column can have a different type: for example you could have a column of gene names (character), a column of gene counts (numeric) and another column telling you whether or not the gene is protein-coding (logical). For this reason, data frames are the most common data structure used in R.\nYou can create a data frame using the data.frame() function. The arguments are vectors of values to be put into the data frame, with the names of the vectors becoming the column names:\n\n# create a data frame\nmouse_facts &lt;- data.frame(\n  name = c(\"mickey\", \"minnie\", \"stuart\"),\n  age = c(12, 8, 16),\n  weight = c(39.7, 42.2, 46.3)\n)\n\n# print the data frame\nmouse_facts\n\n    name age weight\n1 mickey  12   39.7\n2 minnie   8   42.2\n3 stuart  16   46.3\n\n\nWhen creating a data frame, it’s important that all vectors are the same length. If they’re not, you’ll get an error:\n\nmouse_facts &lt;- data.frame(\n  name = c(\"mickey\", \"minnie\", \"stuart\"),\n  age = c(12, 8), # forgot to add stuart's age!\n  weight = c(39.7, 42.2, 46.3)\n)\n\nError in data.frame(name = c(\"mickey\", \"minnie\", \"stuart\"), age = c(12, : arguments imply differing number of rows: 3, 2\n\n\nFor the rest of this section, we’ll use the iris data set that comes pre-loaded in R. This is a bigger data set that contains measurements of different species of iris flowers, and will help us to learn how to work with data frames in R.\nFirst, let’s load in the dataset using the data() function:\n\ndata(iris)\n\niris has the class data.frame:\n\nclass(iris)\n\n[1] \"data.frame\"\n\n\nJust like for vectors, there are functions to look at the contents of a data frame. This is useful as printing the whole data frame can be overwhelming if it’s large (try printing iris and see for yourself!). The head() and tail() functions work the same way as for vectors:\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\ntail(iris)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n145          6.7         3.3          5.7         2.5 virginica\n146          6.7         3.0          5.2         2.3 virginica\n147          6.3         2.5          5.0         1.9 virginica\n148          6.5         3.0          5.2         2.0 virginica\n149          6.2         3.4          5.4         2.3 virginica\n150          5.9         3.0          5.1         1.8 virginica\n\n\nYou can also use the View() function to open the data frame in a new tab in RStudio:\n\n# don't forget the captial V!\nView(iris)\n\nThis will open a new tab in RStudio with the data frame displayed in a spreadsheet-like format, where you can sort and filter the columns to get a better view of the data:\n\n\n\nThe View() function opens the data frame in a new tab in RStudio\n\n\nAnother way to view the data frame is by clicking on its name in the environment panel:\n\n\n\nClicking on the data frame’s name in the environment panel opens it in the viewer\n\n\nThis panel also shows you the names and types of the columns in the data frame. You might notice that the Species is described as a factor, which is a special type of data in R that we’ll cover in Chapter 3.\nBefore the column names, you’ll see the $ symbol. The dollar sign $ is a shortcut used in R to access columns of a data frame. For example, to access the Petal.Width column of the iris data frame, you can use iris$Petal.Width:\n\niris$Petal.Width\n\n  [1] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 0.2 0.2 0.1 0.1 0.2 0.4 0.4 0.3\n [19] 0.3 0.3 0.2 0.4 0.2 0.5 0.2 0.2 0.4 0.2 0.2 0.2 0.2 0.4 0.1 0.2 0.2 0.2\n [37] 0.2 0.1 0.2 0.2 0.3 0.3 0.2 0.6 0.4 0.3 0.2 0.2 0.2 0.2 1.4 1.5 1.5 1.3\n [55] 1.5 1.3 1.6 1.0 1.3 1.4 1.0 1.5 1.0 1.4 1.3 1.4 1.5 1.0 1.5 1.1 1.8 1.3\n [73] 1.5 1.2 1.3 1.4 1.4 1.7 1.5 1.0 1.1 1.0 1.2 1.6 1.5 1.6 1.5 1.3 1.3 1.3\n [91] 1.2 1.4 1.2 1.0 1.3 1.2 1.3 1.3 1.1 1.3 2.5 1.9 2.1 1.8 2.2 2.1 1.7 1.8\n[109] 1.8 2.5 2.0 1.9 2.1 2.0 2.4 2.3 1.8 2.2 2.3 1.5 2.3 2.0 2.0 1.8 2.1 1.8\n[127] 1.8 1.8 2.1 1.6 1.9 2.0 2.2 1.5 1.4 2.3 2.4 1.8 1.8 2.1 2.4 2.3 1.9 2.3\n[145] 2.5 2.3 1.9 2.0 2.3 1.8\n\n\nTry typing this code into your R script. You’ll notice once you write iris$, RStudio will list out all of the columns like so:\n\n\n\nRStudio will suggest column names as you type\n\n\nYou can navigate through these suggestions using the up and down arrow keys, and press EnterEnter or TabTab to select the column you want.\nThese columns are vectors, so you can use the functions we’ve learned about so far to work with them:\n\n# find the class of the Petal.Width column\nclass(iris$Petal.Width)\n\n[1] \"numeric\"\n\n# find the average Petal.Width column\nmean(iris$Petal.Width)\n\n[1] 1.199333\n\n\n\n\n\n\n\n\nTibbles and data frames\n\n\n\nTibbles are a more modern version of data frames introduced in the tidyverse. They are very similar to data frames, but have some additional features like printing more nicely in the console.\nLet’s use iris to highlight the advantages of tibbles:\n\n# need to load the tidyverse package to use tibbles\nlibrary(tidyverse)\n\nWhen we print a data frame, it shows every single row and column, which can be overwhelming if the data frame is large:\n\n\nClick here to print iris as a data frame!\n\n\n# print iris\niris\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1            5.1         3.5          1.4         0.2     setosa\n2            4.9         3.0          1.4         0.2     setosa\n3            4.7         3.2          1.3         0.2     setosa\n4            4.6         3.1          1.5         0.2     setosa\n5            5.0         3.6          1.4         0.2     setosa\n6            5.4         3.9          1.7         0.4     setosa\n7            4.6         3.4          1.4         0.3     setosa\n8            5.0         3.4          1.5         0.2     setosa\n9            4.4         2.9          1.4         0.2     setosa\n10           4.9         3.1          1.5         0.1     setosa\n11           5.4         3.7          1.5         0.2     setosa\n12           4.8         3.4          1.6         0.2     setosa\n13           4.8         3.0          1.4         0.1     setosa\n14           4.3         3.0          1.1         0.1     setosa\n15           5.8         4.0          1.2         0.2     setosa\n16           5.7         4.4          1.5         0.4     setosa\n17           5.4         3.9          1.3         0.4     setosa\n18           5.1         3.5          1.4         0.3     setosa\n19           5.7         3.8          1.7         0.3     setosa\n20           5.1         3.8          1.5         0.3     setosa\n21           5.4         3.4          1.7         0.2     setosa\n22           5.1         3.7          1.5         0.4     setosa\n23           4.6         3.6          1.0         0.2     setosa\n24           5.1         3.3          1.7         0.5     setosa\n25           4.8         3.4          1.9         0.2     setosa\n26           5.0         3.0          1.6         0.2     setosa\n27           5.0         3.4          1.6         0.4     setosa\n28           5.2         3.5          1.5         0.2     setosa\n29           5.2         3.4          1.4         0.2     setosa\n30           4.7         3.2          1.6         0.2     setosa\n31           4.8         3.1          1.6         0.2     setosa\n32           5.4         3.4          1.5         0.4     setosa\n33           5.2         4.1          1.5         0.1     setosa\n34           5.5         4.2          1.4         0.2     setosa\n35           4.9         3.1          1.5         0.2     setosa\n36           5.0         3.2          1.2         0.2     setosa\n37           5.5         3.5          1.3         0.2     setosa\n38           4.9         3.6          1.4         0.1     setosa\n39           4.4         3.0          1.3         0.2     setosa\n40           5.1         3.4          1.5         0.2     setosa\n41           5.0         3.5          1.3         0.3     setosa\n42           4.5         2.3          1.3         0.3     setosa\n43           4.4         3.2          1.3         0.2     setosa\n44           5.0         3.5          1.6         0.6     setosa\n45           5.1         3.8          1.9         0.4     setosa\n46           4.8         3.0          1.4         0.3     setosa\n47           5.1         3.8          1.6         0.2     setosa\n48           4.6         3.2          1.4         0.2     setosa\n49           5.3         3.7          1.5         0.2     setosa\n50           5.0         3.3          1.4         0.2     setosa\n51           7.0         3.2          4.7         1.4 versicolor\n52           6.4         3.2          4.5         1.5 versicolor\n53           6.9         3.1          4.9         1.5 versicolor\n54           5.5         2.3          4.0         1.3 versicolor\n55           6.5         2.8          4.6         1.5 versicolor\n56           5.7         2.8          4.5         1.3 versicolor\n57           6.3         3.3          4.7         1.6 versicolor\n58           4.9         2.4          3.3         1.0 versicolor\n59           6.6         2.9          4.6         1.3 versicolor\n60           5.2         2.7          3.9         1.4 versicolor\n61           5.0         2.0          3.5         1.0 versicolor\n62           5.9         3.0          4.2         1.5 versicolor\n63           6.0         2.2          4.0         1.0 versicolor\n64           6.1         2.9          4.7         1.4 versicolor\n65           5.6         2.9          3.6         1.3 versicolor\n66           6.7         3.1          4.4         1.4 versicolor\n67           5.6         3.0          4.5         1.5 versicolor\n68           5.8         2.7          4.1         1.0 versicolor\n69           6.2         2.2          4.5         1.5 versicolor\n70           5.6         2.5          3.9         1.1 versicolor\n71           5.9         3.2          4.8         1.8 versicolor\n72           6.1         2.8          4.0         1.3 versicolor\n73           6.3         2.5          4.9         1.5 versicolor\n74           6.1         2.8          4.7         1.2 versicolor\n75           6.4         2.9          4.3         1.3 versicolor\n76           6.6         3.0          4.4         1.4 versicolor\n77           6.8         2.8          4.8         1.4 versicolor\n78           6.7         3.0          5.0         1.7 versicolor\n79           6.0         2.9          4.5         1.5 versicolor\n80           5.7         2.6          3.5         1.0 versicolor\n81           5.5         2.4          3.8         1.1 versicolor\n82           5.5         2.4          3.7         1.0 versicolor\n83           5.8         2.7          3.9         1.2 versicolor\n84           6.0         2.7          5.1         1.6 versicolor\n85           5.4         3.0          4.5         1.5 versicolor\n86           6.0         3.4          4.5         1.6 versicolor\n87           6.7         3.1          4.7         1.5 versicolor\n88           6.3         2.3          4.4         1.3 versicolor\n89           5.6         3.0          4.1         1.3 versicolor\n90           5.5         2.5          4.0         1.3 versicolor\n91           5.5         2.6          4.4         1.2 versicolor\n92           6.1         3.0          4.6         1.4 versicolor\n93           5.8         2.6          4.0         1.2 versicolor\n94           5.0         2.3          3.3         1.0 versicolor\n95           5.6         2.7          4.2         1.3 versicolor\n96           5.7         3.0          4.2         1.2 versicolor\n97           5.7         2.9          4.2         1.3 versicolor\n98           6.2         2.9          4.3         1.3 versicolor\n99           5.1         2.5          3.0         1.1 versicolor\n100          5.7         2.8          4.1         1.3 versicolor\n101          6.3         3.3          6.0         2.5  virginica\n102          5.8         2.7          5.1         1.9  virginica\n103          7.1         3.0          5.9         2.1  virginica\n104          6.3         2.9          5.6         1.8  virginica\n105          6.5         3.0          5.8         2.2  virginica\n106          7.6         3.0          6.6         2.1  virginica\n107          4.9         2.5          4.5         1.7  virginica\n108          7.3         2.9          6.3         1.8  virginica\n109          6.7         2.5          5.8         1.8  virginica\n110          7.2         3.6          6.1         2.5  virginica\n111          6.5         3.2          5.1         2.0  virginica\n112          6.4         2.7          5.3         1.9  virginica\n113          6.8         3.0          5.5         2.1  virginica\n114          5.7         2.5          5.0         2.0  virginica\n115          5.8         2.8          5.1         2.4  virginica\n116          6.4         3.2          5.3         2.3  virginica\n117          6.5         3.0          5.5         1.8  virginica\n118          7.7         3.8          6.7         2.2  virginica\n119          7.7         2.6          6.9         2.3  virginica\n120          6.0         2.2          5.0         1.5  virginica\n121          6.9         3.2          5.7         2.3  virginica\n122          5.6         2.8          4.9         2.0  virginica\n123          7.7         2.8          6.7         2.0  virginica\n124          6.3         2.7          4.9         1.8  virginica\n125          6.7         3.3          5.7         2.1  virginica\n126          7.2         3.2          6.0         1.8  virginica\n127          6.2         2.8          4.8         1.8  virginica\n128          6.1         3.0          4.9         1.8  virginica\n129          6.4         2.8          5.6         2.1  virginica\n130          7.2         3.0          5.8         1.6  virginica\n131          7.4         2.8          6.1         1.9  virginica\n132          7.9         3.8          6.4         2.0  virginica\n133          6.4         2.8          5.6         2.2  virginica\n134          6.3         2.8          5.1         1.5  virginica\n135          6.1         2.6          5.6         1.4  virginica\n136          7.7         3.0          6.1         2.3  virginica\n137          6.3         3.4          5.6         2.4  virginica\n138          6.4         3.1          5.5         1.8  virginica\n139          6.0         3.0          4.8         1.8  virginica\n140          6.9         3.1          5.4         2.1  virginica\n141          6.7         3.1          5.6         2.4  virginica\n142          6.9         3.1          5.1         2.3  virginica\n143          5.8         2.7          5.1         1.9  virginica\n144          6.8         3.2          5.9         2.3  virginica\n145          6.7         3.3          5.7         2.5  virginica\n146          6.7         3.0          5.2         2.3  virginica\n147          6.3         2.5          5.0         1.9  virginica\n148          6.5         3.0          5.2         2.0  virginica\n149          6.2         3.4          5.4         2.3  virginica\n150          5.9         3.0          5.1         1.8  virginica\n\n\n\nBut when we print a tibble, only a small preview is shown, which is much easier to read:\n\n# print iris as a tibble\nas_tibble(iris)\n\n# A tibble: 150 × 5\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  \n 1          5.1         3.5          1.4         0.2 setosa \n 2          4.9         3            1.4         0.2 setosa \n 3          4.7         3.2          1.3         0.2 setosa \n 4          4.6         3.1          1.5         0.2 setosa \n 5          5           3.6          1.4         0.2 setosa \n 6          5.4         3.9          1.7         0.4 setosa \n 7          4.6         3.4          1.4         0.3 setosa \n 8          5           3.4          1.5         0.2 setosa \n 9          4.4         2.9          1.4         0.2 setosa \n10          4.9         3.1          1.5         0.1 setosa \n# ℹ 140 more rows\n\n\nIt also tells us the number of rows (150) and columns (5) in the data, as well as the types of each column (&lt;dbl&gt; is short for double, which is a type of numeric data).\nFor the purpose of this course, we can treat tibbles and data frames as the same thing. However, if you’re interested in learning more about tibbles, you can read about them here.\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. Which of the following is NOT a valid vector in R?\n\n\n\n\n ✗c(TRUE, FALSE, FALSE)\n\n\n ✔(1, 2, 3, 4)\n\n\n ✗1:10\n\n\n ✗c(\"cat\", \"dog\", \"fish\")\n\n\n\n\n\n\n2. What is the result of running this R code: c(1, 2, 3) * 2?\n\n\n\n\n ✗2(1, 2, 3)\n\n\n ✗c(1, 2, 3, 1, 2, 3)\n\n\n ✗c(1, 2, 3, 2)\n\n\n ✔c(2, 4, 6)\n\n\n\n\n\n\n3. What is the difference between a matrix and a data frame?\n\n\n\n\n ✔A matrix has all elements of the same type, while a data frame can have different types in each column\n\n\n ✗They’re the same thing\n\n\n ✗A matrix can only contain numbers, while a data frame can contain numbers and text\n\n\n ✗A matrix is used for mathematical operations, while a data frame is used for data analysis\n\n\n\n\n\n\n4. I wrote this code to create a data frame, but it gave me an error. What is wrong with it?\n\nfavourite_fruits &lt;- data.frame(\n  fruit = c(\"apple\", \"banana\", \"cherry\"),\n  colour = c(\"red\", \"yellow\", \"red\"),\n  price = c(0.5, 0.3)\n)\n\n\n\n\n\n ✗The column names are not in quotation marks\n\n\n ✔The columns are not the same length: ‘fruit’ and ‘colour’ have 3 elements, but ‘price’ has 2\n\n\n ✗It’s not allowed to have character columns and numeric columns in the same data frame\n\n\n ✗You should use the tibble() function instead of data.frame()\n\n\n\n\n\n\n5. What is NOT a way that I could view the contents of a data frame in R?\n\n\n\n\n ✗Running the name of the data frame as code in the R script panel\n\n\n ✗Typing the name of the data frame into the console\n\n\n ✗Clicking on its name in the environment panel\n\n\n ✔Using the view() function\n\n\n\n\n\n\n6. I have created the mouse_facts data frame using the code below. How would I calculate the average age of the mice?\n\nmouse_facts &lt;- data.frame(\n  name = c(\"mickey\", \"minnie\", \"stuart\"),\n  age = c(12, 8, 16),\n  weight = c(39.7, 42.2, 46.3)\n)\n\n\n\n\n\n ✗mean(age)\n\n\n ✔mean(mouse_facts$age)\n\n\n ✗average(age)\n\n\n ✗average(mouse_facts$age)\n\n\n\n\n\n\n\nSolutions\n\n1. The vector (1, 2, 3, 4) is not a valid vector: you need to use the c() function to create a vector in R. The exception is the colon : notation, which creates a sequence of numbers.\n2. The result of running c(1, 2, 3) * 2 would be c(2, 4, 6). This is because R is a vectorised language, so the * operator multiplies each element of the vector by 2.\n3. The difference between a matrix and a data frame is that a matrix has all elements of the same type (could be character, logical or numeric), while a data frame can have different types in each column.\n4. The code to create the data frame favourite_fruits gave an error because the columns are not the same length: ‘fruit’ and ‘colour’ have 3 elements, but ‘price’ has 2. You can’t create a data frame with columns of different lengths. As for the other options, you can have character and numeric columns in the same data frame, the column names don’t need to be in quotation marks (although the code will work if they are), and the tibble() function is an alternative to data.frame() but either is fine.\n5. Using the view() function is not a way to view the contents of a data frame in R. The correct function is View() (with a capital ‘V’). All the other options are valid ways to view the contents of a data frame.\n6. To calculate the average age of the mice, you would use mean(mouse_facts$age). This is because the age column is part of the mouse_facts data frame, so you need to use the $ symbol to access it, and the function for calculating the average in R is mean().",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#sec-readingin",
    "href": "session_1.html#sec-readingin",
    "title": "1  Session 1: Introduction to R",
    "section": "1.8 Reading in data",
    "text": "1.8 Reading in data\nSo far, we’ve explored the basics of R by creating our own data, or using built-in data objects like letters or iris. However, in real life analyses, we almost always need to read in data from files on our computers.\nIn this section we will use the file named mousezempic_dosage_data.csv, which you can download using the button below:\n Download the example data file \nPlace this file into the project directory you have made for this course (it’s generally a good idea to keep all the data and code for a certain analysis together). If you’d like to be more organised, try placing it in a folder called ‘data’.\n\n1.8.1 Paths\nPaths tell R where to find the file you want to read in. They are strings of characters that first include the directory or series of directories in which a file is located, followed by the name of the file itself. For example, the path to a file called my_data.csv in a folder called data would be data/my_data.csv.\nIn this course, we will use RStudio to help us find the paths to our files, without needing to type them out ourselves. If you’re interested in learning more about paths, codeacademy has a nice simple article on them.\nTo find a file path easily in RStudio, you can use the file explorer panel. First, open it by clicking on the ‘Files’ tab in the bottom right panel of RStudio:\n\n\n\nThe file explorer panel in RStudio\n\n\nBy default, it will put you in your project directory. If you have data files in a different directory, you can navigate to that directory by clicking on the folders. Here, I have navigated to a folder on my desktop called ‘important_data’. Once you’re in the right place, to get the path for that folder, click on More &gt; Copy Folder Path to Clipboard:\n\n\n\nCopying the folder path to the clipboard\n\n\nThis will copy the path to the folder to your clipboard, which you can then paste into your R script. Then, you just need to add a / followed by the name of the file to the end of the path. For example, the path to the folder in the above image is ~/Desktop/R_course/data, so the path to the mousezempic_dosage_data.csv file is ~/Desktop/R_course/data/mousezempic_dosage_data.csv.\n\n\n1.8.2 Reading data with functions\nNow that we know how to find our data, we can read it in. We’ll do this using a handy package called readr.\n\n\n\n\n\n\nPackages in R\n\n\n\nPackages are collections of functions that other people have written to help us do specific tasks, beyond what is built-in to R itself. The tidyverse is a collection of packages that help to streamline data analysis in R. readr is a tidyverse package that helps us to read in data from files. Whenever we want to use functions from a package, we need to load it into our R session first by using the library() function.\n\n\nFirst, let’s load the readr package:\n\n# load the readr package\nlibrary(readr)\n\nIf running this code gives you an error message, you might need to install the readr package first. Visit Section 2 of the setup part of this book for instructions on how to install the tidyverse package, which includes readr and other important packages we will use in this course.\nTo read in our data, we’ll use the read_delim() function from the readr package. This function takes in the path to the file you want to read in (in quotation marks \"\", as this is a character string) and returns as output a tibble (recall this is basically the same as a data frame)\n\nread_delim(\"~/Desktop/R_course/data/mousezempic_dosage_data.csv\")\n\nDepending on where you have put your data, your path to the mousezempic_dosage_data.csv file may be different. You should be able to find the path by following the instructions in the ‘Paths’ section above.\nNow, let’s take a look at the output of read_delim():\n\n\nRows: 344 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): mouse_strain, cage_number, replicate, sex\ndbl (4): weight_lost_g, drug_dose_g, tail_length_mm, initial_weight_g\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;\n\n\nThe first line tells us how many rows and columns are in the data. Then, the Column specification section tells you:\n\nWhat delimiter was used to separate values.\nWhich columns belong to each type. read_delim() is quite clever and will guess this for us, but it’s useful to check and make sure it’s correct.\n\nThen, the data will be printed out as a tibble.\n\n\n\n\n\n\nDelimiters\n\n\n\nThe ‘delim’ in ‘read_delim’ stands for delimiter, and refers to the character used to separates columns of the data.\nThe most common types of delimiter are comma-separated values (.csv files) and tab-separated values (.tsv files). Here’s an example of what they look like:\n\n\nexample.csv\n\nName, Age\nAndy, 10\nBob, 8\n\n\n\n\n\nexample.tsv\n\nName  Age\nAndy  10\nBob   8\n\nBy default read_delim() will guess your delimiter, so it’s easiest to use that to read files, no matter their format. However, if you read other people’s code, you might also encounter the read_tsv() and read_csv() functions which are specifically for reading in tab-separated and comma-separated files, respectively. It’s up to you which you use, just make sure to get the delimiter right! If you try to read in a file with the wrong delimiter, it’ll look like a mess.\n\n\nWhat happens if we use the wrong delimiter?\n\nAs an example, let’s try reading in our comma-separated file with read_tsv(), which is specifically for tab-separated files:\n\nread_tsv(\"~/Desktop/R_course/data/mousezempic_dosage_data.csv\")\n\n\n\nRows: 344 Columns: 1\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr (1): mouse_strain,cage_number,weight_lost_g,replicate,sex,drug_dose_g,ta...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n# A tibble: 344 × 1\n   mouse_strain,cage_number,weight_lost_g,replicate,sex,drug_dose_g,tail_lengt…¹\n   &lt;chr&gt;                                                                        \n 1 CD-1,1A,3.75,rep1,male,0.00181,18.7,39.1                                     \n 2 CD-1,1A,3.8,rep1,female,0.0018600000000000001,17.4,39.5                      \n 3 CD-1,1A,3.25,rep1,female,0.00195,18,40.3                                     \n 4 CD-1,1A,NA,rep1,NA,NA,NA,NA                                                  \n 5 CD-1,1A,3.45,rep1,female,0.0019299999999999999,19.3,36.7                     \n 6 CD-1,1A,3.65,rep1,male,0.0019,20.6,39.3                                      \n 7 CD-1,1A,3.625,rep1,female,0.00181,17.8,38.9                                  \n 8 CD-1,1A,4.675,rep1,male,0.00195,19.6,39.2                                    \n 9 CD-1,1A,3.475,rep1,NA,0.0019299999999999999,18.1,34.1                        \n10 CD-1,1A,4.25,rep1,NA,0.0019,20.2,42                                          \n# ℹ 334 more rows\n# ℹ abbreviated name:\n#   ¹​`mouse_strain,cage_number,weight_lost_g,replicate,sex,drug_dose_g,tail_length_mm,initial_weight_g`\n\n\nWe can see that the data is all in one column, which is not what we want!\n\n\n\nNo matter which function you use to read in your data, R simply prints the values out in the console. To actually work with data in R, we need assign our data frame to a variable:\n\ndosage_data &lt;- read_delim(\"~/Desktop/R_course/data/mousezempic_dosage_data.csv\")\n\n\n\nRows: 344 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): mouse_strain, cage_number, replicate, sex\ndbl (4): weight_lost_g, drug_dose_g, tail_length_mm, initial_weight_g\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n1.8.3 Reading data through RStudio’s graphical interface\nYou can also read in data through RStudio’s graphical interface. This is a good way to get the code to read in data if you’re not sure how to do it yourself.\nTo do this, click on the ‘Import Dataset’ button in the environment panel (for our data, we will use the ‘from Text (readr)’ option):\n\n\n\nThe import dataset button in the environment panel\n\n\nThis will open a window where you can select the file you want to read in, like so:\n\n\n\nThe import dataset window in RStudio\n\n\nR will then generate the code to read in the data for you, and you can use the preview to check that it has worked ok:\n\n\n\nRStudio will then read in the data, and give you the code that it used\n\n\nYou can then copy this code and paste it into your script. This step is really important because not only does it helps you to learn how to read in data yourself, it keeps a record in the script of how you read in the data so that you can reproduce your analysis later.\n\n\n\nDon’t forget to paste the code into the script!!!\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What is a path?\n\n\n\n\n ✗A type of data in R\n\n\n ✗The data you want to analyse\n\n\n ✔A string of characters that tells R where to find a file\n\n\n ✗A function in R\n\n\n\n\n\n\n2. What is NOT a way to read in a file called my_data.tsv in R?\n\n\n\n\n ✗Using the read_delim() function\n\n\n ✗Using the ‘Import Dataset’ button in RStudio\n\n\n ✗Using the read_tsv() function\n\n\n ✔Using the read_csv() function\n\n\n\n\n\n\n3. What do we need to do before we can use functions from readr or any other R package?\n\n\n\n\n ✗Install it\n\n\n ✔Install it, then load it into our R session using the library() function\n\n\n ✗Download it\n\n\n ✗Look at the help page for the functions we want to use\n\n\n\n\n\n\n\nSolutions\n\n1. A path is a string of characters that tells R where to find a file. Note that it isn’t the data itself, but rather the location of the data.\n2. The read_csv() function is not a way to read in a file called my_data.tsv, because it is specifically for reading in comma-separated files, so it would not work for a tab-separated file like my_data.tsv.\n3. Before we can use functions from readr or any other R package, we need to install it, then load it into our R session using the library() function. Otherwise we will get an error message when we try to use the functions.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_1.html#summary",
    "href": "session_1.html#summary",
    "title": "1  Session 1: Introduction to R",
    "section": "1.9 Summary",
    "text": "1.9 Summary\n\nHere’s what we’ve learnt in this session:\n\nHow to create an R project (to keep our files organised) and how to write and run code from an R script (so that the code is saved as a record of our work)\nThe operators for basic maths (*, /, + and -) and comparisons (==, &lt;, &lt;= and !)\nHow to use functions and specify their arguments, as well as how to get help\nHow to assign variables using the &lt;- operator, and how to name them appropriately\nThe three basic atomic data types in R (character, numeric and logical)\nThree different data structures in R (vectors, matrices and data frames/tibbles)\nHow to find file paths using RStudio\nHow to load the readr package and use it to read in files\n\nTry the practice questions below to test your understanding!\n\n1.9.1 Practice questions\n\nWhat would be the result of evaluating the following expressions? You don’t need to know these off the top of your head, use R to help! (Hint: some expressions might give an error. Try to think about why)\n\n5 + 10\n100 &gt;= (5 + 2) ^ 2\n!(100 &gt; 1)\n500 = 5 * 100\n2fast &lt;- \"zoom\"\nround(428.195721, 2)\n?t.test\nclass(\"banana\")\nclass(as.numeric(\"500\"))\n\"1\" + \"10\"\nlength(1:100)\nsum(c(1, 2, 3, 4))\nhead(iris)\nmean(iris$Sepal.Width)\nread_tsv(\"gene_counts.csv\")\n\nWrite some R code to complete the right-hand side of this comparison: as.numeric(\"100\") * 3 ==\nI wrote the following R code, and got an error. How can I fix it?\n\n# the number of frogs I counted\nFrog_counts &lt;- c(11, 2, 4, 9, 10)\n\n# convert to a proportion: divide by the sum\nfrog_counts / sum(Frog_counts)\n\nError in eval(expr, envir, enclos): object 'frog_counts' not found\n\n\nLoad the iris dataframe into your R session using data(iris). What is the median petal length? Show the code you used to calculate this.\nImagine I have a file called mouse_survival.tsv located in a folder with the path ~/Downloads/experimental_data/latest. Write a line of R code to read in this file and assign it to a variable called mouse_survival\n\n\n\nSolutions\n\n\nThe results of evaluating the expressions are:\n\n5 + 10 is 15\n100 &gt;= (5 + 2) ^ 2 is TRUE\n!(100 &gt; 1) is FALSE (although 100 is greater than 1, the ! operator negates this)\n500 = 5 * 100 gives an error because we need two equals signs == to check for equality in R. Actually this code is trying to assign the value of 5 * 100 to the variable 500, which is not allowed, because variable names can’t start with a number.\n2fast &lt;- \"zoom\" gives an error because variable names can’t start with a number\nround(428.195721, 2) is 428.2\n?t.test opens the help page for the t.test() function\nclass(\"banana\") is \"character\"\nclass(as.numeric(\"500\")) is \"numeric\"\n\"1\" + \"10\" gives an error because you can’t add two character strings together\nlength(1:100) is 100\nsum(c(1, 2, 3, 4)) is 10\nhead(iris) shows the first 6 rows of the iris data frame\nmean(iris$Sepal.Width) is the average of the Sepal.Width column in the iris data frame\nread_tsv(\"gene_counts.csv\") will try to read in gene_counts.csv as if it were tab-separated, which will result in all the data being in one column\n\nThe right-hand side of the comparison as.numeric(\"100\") * 3 == can be anything that results in 300 e.g. 300 or 299 + 1, for example\nThe error in the code is because the variable name Frog_counts is not the same as frog_counts. R is case-sensitive, so it thinks you are trying to divide a variable that doesn’t exist. To fix this, make sure all your variables have the same case (lowercase is better!):\n\n\n    # the number of frogs I counted\n    frog_counts &lt;- c(11, 2, 4, 9, 10)\n\n    # convert to a proportion: divide by the sum\n    frog_counts / sum(frog_counts)\n\n[1] 0.30555556 0.05555556 0.11111111 0.25000000 0.27777778\n\n\n\nTo calculate the median petal length in the iris data frame, you can use median(iris$Petal.Length)\nTo read in the mouse_survival.tsv file and assign it to a variable called mouse_survival, you could use red_delim(): mouse_survival &lt;- read_delim(\"~/Downloads/experimental_data/latest/mouse_survival.tsv\") or read_tsv(): mouse_survival &lt;- read_tsv(\"~/Downloads/experimental_data/latest/mouse_survival.tsv\").",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Session 1: Introduction to R</span>"
    ]
  },
  {
    "objectID": "session_2.html",
    "href": "session_2.html",
    "title": "2  Session 2: Working with data",
    "section": "",
    "text": "2.1 Chaining functions together with pipes\nIn this session we will learn how to manipulate and summarise data using the dplyr package.\nMake sure you have dplyr package loaded by running library(dplyr), otherwise you will not be able to run the code in this session.\nYou’ll see some output from the dplyr package when you load it, which is just telling you that some of dplyr’s functions have the same name as other functions in R.\nPipes are a powerful feature of the tidyverse that allow you to chain multiple functions together. Pipes are useful because they allow you to break down complex operations into smaller steps that are easier to read and understand.\nFor example, take the following code:\nmy_vector &lt;- c(1, 2, 3, 4, 5)\nas.character(round(mean(my_vector)))\n\n[1] \"3\"\nWhat do you think this code does? It calculates the mean of my_vector, rounds the result to the nearest whole number, and then converts the result to a character. But the code is a bit hard to read because you have to start from the inside of the brackets and work your way out.\nInstead, we can use the pipe operator (%&gt;%) to chain these functions together in a more readable way:\nmy_vector &lt;- c(1, 2, 3, 4, 5)\nmy_vector %&gt;% mean() %&gt;% round() %&gt;% as.character()\n\n[1] \"3\"\nSee how the code reads naturally from left to right? You can think of the pipe as being like the phrase “and then”. Here, we’re telling R: “Take my_vector, and then calculate the mean, and then round the result, and then convert it to a character.”\nYou’ll notice that we didn’t need to specify the input to each function. That’s because the pipe automatically passes the output of the previous function as the first input to the next function. We can still specify additional arguments to each function if we need to. For example, if we wanted to round the mean to 2 decimal places, we could do this:\nmy_vector %&gt;% mean() %&gt;% round(digits = 2) %&gt;% as.character()\n\n[1] \"3\"\nR is clever enough to know that the first argument to round() is still the output of mean(), even though we’ve now specified the digits argument.\nTo type the pipe operator more easily, you can use the keyboard shortcut Cmd-shift-MCmd-shift-M (although once you get used to it, you might find it easier to type %&gt;% manually).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#sec-pipes",
    "href": "session_2.html#sec-pipes",
    "title": "2  Session 2: Working with data",
    "section": "",
    "text": "Plenty of pipes\n\n\n\nThere is another style of pipe in R, called the ‘base R pipe’ |&gt;, which is available in R version 4.1.0 and later. The base R pipe works in a similar way to the magrittr pipe (%&gt;%) that we use in this course, but it is not as flexible. We recommend using the magrittr pipe for now.\nFun fact: the magrittr package is named after the artist René Magritte, who made a famous painting of a pipe.\n\n\n\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. What is NOT a valid way to re-write the following code using the pipe operator: round(sqrt(sum(1:10)), 1). If you’re not sure, try running the different options in the console to see which one gives the same answer.\n\n\n\n\n ✗1:10 %&gt;% sum() %&gt;% sqrt() %&gt;% round(1)\n\n\n ✔sum(1:10) %&gt;% sqrt(1) %&gt;% round()\n\n\n ✗1:10 %&gt;% sum() %&gt;% sqrt() %&gt;% round(digits = 1)\n\n\n ✗sum(1:10) %&gt;% sqrt() %&gt;% round(digits = 1)\n\n\n\n\n\n\n2. What is the output of the following code? letters %&gt;% head() %&gt;% toupper() Try to guess it before copy-pasting into R.\n\n\n\n\n ✗\"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n\n ✗\"a\" \"b\" \"c\" \"d\" \"e\" \"f\"\n\n\n ✗An error\n\n\n ✔\"A\" \"B\" \"C\" \"D\" \"E\" \"F\"\n\n\n\n\n\n\n\nSolutions\n\n\n\nThe invalid option is sum(1:10) %&gt;% sqrt(1) %&gt;% round(). This is because the sqrt() function only takes one argument, so you can’t specify 1 as an argument in addition to what is being piped in from sum(1:10). Note that some options used the pipe to send 1:10 to sum() (like 1:10 %&gt;% sum()), and others just used sum(1:10) directly. Both are valid ways to use the pipe, it’s just a matter of personal preference.\nThe output of the code letters %&gt;% head() %&gt;% toupper() is \"A\" \"B\" \"C\" \"D\" \"E\" \"F\". The letters vector contains the lowercase alphabet, and the head() function returns the first 6 elements of the vector. Finally, the toupper() function then converts these elements to uppercase.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#sec-dataManip",
    "href": "session_2.html#sec-dataManip",
    "title": "2  Session 2: Working with data",
    "section": "2.2 Basic data maniuplations",
    "text": "2.2 Basic data maniuplations\nTo really see the power of the pipe, we will use it together with the dplyr package that provides a set of functions to easily filter, sort, select, and summarise data frames. These functions are designed to work well with the pipe, so you can chain them together to create complex data manipulations in a readable format.\nFor example, even though we haven’t covered the dplyr functions yet, you can probably guess what the following code does:\n\n# use the pipe to chain together our data manipulation steps\nmousezempic_dosage_data %&gt;%\n  filter(cage_number == \"3E\") %&gt;%\n  pull(weight_lost_g) %&gt;%\n  mean()\n\nThis code filters the mousezempic_dosage_data data frame to only include data from cage 3E, then pulls out the weight_lost_g column, and finally calculates the mean of the values in that column. The first argument to each function is the output of the previous function, and any additional arguments (like the column name in pull()) are specified in the brackets (like round(digits = 2) from the previous example).\nWe also used the enter key after each pipe %&gt;% to break up the code into multiple lines to make it easier to read. This isn’t required, but is a popular style in the R community, so all the code examples in this session will follow this format.\nWe will now introduce some of the most commonly used dplyr functions for manipulating data frames. To showcase these, we will use the mousezempic_dosage_data that we practiced reading in last session. This imaginary dataset contains information on the weight lost by different strains of mice after being treated with different doses of MouseZempic®.\n\n# read in the data, like we did in session 1\nlibrary(readr)\nmousezempic_dosage_data &lt;- read_delim(\"~/Desktop/R_course/data/mousezempic_dosage_data.csv\")\n\n\n\nRows: 344 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): mouse_strain, cage_number, replicate, sex\ndbl (4): weight_lost_g, drug_dose_g, tail_length_mm, initial_weight_g\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nBefore we start, let’s use what we learned in the previous session to take a look at mousezempic_dosage_data:\n\n# it's a tibble, so prints nicely\nmousezempic_dosage_data\n\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;\n\n\nYou might also like to use View() to open the data in a separate window and get a closer look.\n\n\n\n\n\n\nUsing RStudio autocomplete\n\n\n\nAlthough it’s great to give our data a descriptive name like mousezempic_dosage_data, it can be a bit of a pain to type out every time. Luckily, RStudio has a handy autocomplete feature that can solve this problem. Just start typing the name of the object, and you’ll see it will popup:\n\n\n\nRStudio autocomplete\n\n\nYou can then press TabTab to autocomplete it. If there are multiple objects that start with the same letters, you can use the arrow keys to cycle through the options.\nTry using autocomplete this session to save yourself some typing!\n\n\n\n2.2.1 Sorting data\nOften, one of the first things you might want to do with a dataset is sort it. In dplyr, this is called ‘arranging’ and is done with the arrange() function.\n\n\n\nArrange orders rows by their values in one or more columns\n\n\nBy default, arrange() sorts in ascending order (smallest values first). For example, let’s sort the mousezempic_dosage_data data frame by the weight_lost_g column:\n\nmousezempic_dosage_data %&gt;%\n  arrange(weight_lost_g)\n\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 BALB C       2B                   2.7  rep2      female     0.00192\n 2 CD-1         3E                   2.85 rep2      female     0.00181\n 3 CD-1         3E                   2.85 rep2      female     0.00184\n 4 CD-1         3E                   2.9  rep2      female     0.00187\n 5 CD-1         2B                   2.9  rep2      female     0.00178\n 6 CD-1         1A                   2.9  rep3      female     0.00188\n 7 BALB C       2B                   2.9  rep1      female     0.00187\n 8 CD-1         3E                   2.92 rep3      female     0.00193\n 9 CD-1         2B                   2.98 rep1      &lt;NA&gt;       0.00179\n10 CD-1         2B                   3    rep1      female     0.00185\n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;\n\n\nIf we compare this to when we just printed our data above, we can see that the rows are now sorted so that the mice that lost the least weight are at the top.\nSometimes you might want to sort in descending order instead (largest values first). You can do this by putting the desc() function around your column name, inside arrange():\n\nmousezempic_dosage_data %&gt;%\n  # put desc() around the column name to sort in descending order\n  arrange(desc(weight_lost_g))\n\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n 1 Black 6      3E                   6.3  rep1      male      0.00221\n 2 Black 6      3E                   6.05 rep1      male      0.0023 \n 3 Black 6      3E                   6    rep2      male      0.0022 \n 4 Black 6      3E                   6    rep3      male      0.00222\n 5 Black 6      3E                   5.95 rep2      male      0.00223\n 6 Black 6      3E                   5.95 rep3      male      0.00229\n 7 Black 6      3E                   5.85 rep1      male      0.00213\n 8 Black 6      3E                   5.85 rep1      male      0.00217\n 9 Black 6      3E                   5.85 rep3      male      0.0023 \n10 Black 6      3E                   5.8  rep2      male      0.00229\n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;\n\n\nNow we can see the mice that lost the most weight are at the top.\n\n\n\n\n\n\nComments and pipes\n\n\n\nNotice how in the previous example we have written a comment in the middle of the pipe chain. This is a good practice to help you remember what each step is doing, especially when you have a long chain of functions, and won’t cause any errors as long as you make sure that the comment is on its own line.\nYou can also write comments at the end of the line, just make sure it’s after the pipe operator %&gt;%.\nFor example, these comments are allowed:\n\nmousezempic_dosage_data %&gt;% # a comment here is fine\n  # a comment here is fine\n  arrange(desc(weight_lost_g))\n\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n 1 Black 6      3E                   6.3  rep1      male      0.00221\n 2 Black 6      3E                   6.05 rep1      male      0.0023 \n 3 Black 6      3E                   6    rep2      male      0.0022 \n 4 Black 6      3E                   6    rep3      male      0.00222\n 5 Black 6      3E                   5.95 rep2      male      0.00223\n 6 Black 6      3E                   5.95 rep3      male      0.00229\n 7 Black 6      3E                   5.85 rep1      male      0.00213\n 8 Black 6      3E                   5.85 rep1      male      0.00217\n 9 Black 6      3E                   5.85 rep3      male      0.0023 \n10 Black 6      3E                   5.8  rep2      male      0.00229\n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;\n\n\nBut this will cause an error, because the # is before the pipe, so R treats it as part of the comment (notice how the %&gt;% has changed colour?) and doesn’t know how the two lines relate to each other. It tries to run them separately, which for the first line is ok (it will just print mousezempic_dosage_data):\n\nmousezempic_dosage_data # this comment will cause an error %&gt;%\n\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         1A                   3.75 rep1      male       0.00181\n 2 CD-1         1A                   3.8  rep1      female     0.00186\n 3 CD-1         1A                   3.25 rep1      female     0.00195\n 4 CD-1         1A                  NA    rep1      &lt;NA&gt;      NA      \n 5 CD-1         1A                   3.45 rep1      female     0.00193\n 6 CD-1         1A                   3.65 rep1      male       0.0019 \n 7 CD-1         1A                   3.62 rep1      female     0.00181\n 8 CD-1         1A                   4.68 rep1      male       0.00195\n 9 CD-1         1A                   3.48 rep1      &lt;NA&gt;       0.00193\n10 CD-1         1A                   4.25 rep1      &lt;NA&gt;       0.0019 \n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;\n\n  arrange(desc(weight_lost_g))\n\nError in eval(expr, envir, enclos): object 'weight_lost_g' not found\n\n\nBut for the second line, there is an error that R doesn’t know what the weight_lost_g object is. That’s because it’s a column in the mousezempic_dosage_data data frame, so R only knows what it is in the context of the pipe chain containing that data frame.\n\n\nYou can also sort by multiple columns by passing multiple column names to arrange(). For example, to sort by the strain first and then by the amount of weight lost:\n\n# sort by strain first, then by weight lost\nmousezempic_dosage_data %&gt;%\n  arrange(mouse_strain, weight_lost_g)\n\n# A tibble: 344 × 8\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 BALB C       2B                   2.7  rep2      female     0.00192\n 2 BALB C       2B                   2.9  rep1      female     0.00187\n 3 BALB C       2B                   3.2  rep2      female     0.00187\n 4 BALB C       2B                   3.25 rep1      female     0.00178\n 5 BALB C       2B                   3.25 rep3      male       0.00187\n 6 BALB C       2B                   3.25 rep3      female     0.00191\n 7 BALB C       2B                   3.3  rep1      male       0.00197\n 8 BALB C       2B                   3.3  rep1      female     0.00195\n 9 BALB C       2B                   3.32 rep3      female     0.00199\n10 BALB C       2B                   3.35 rep2      female     0.00187\n# ℹ 334 more rows\n# ℹ 2 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;\n\n\nThis will sort the data frame by strain (according to alphabetical order, as it is a character column), and within each strain, they are then sorted by the amount of weight lost.\n\n\n\n\n\n\nPiping into View()\n\n\n\nIn the above example, we sorted the data by strain and then by weight lost, but because there are so many mice in each strain, the preview shown in our console doesn’t allow us to see the full effect of the sorting.\nOne handy trick you can use with pipes is to add View() at the end of your chain to open the data in a separate window. Try running this code, and you’ll be able to scroll through the full dataset to check that the other mouse strains have also been sorted correctly:\n\n# sort by strain first, then by weight lost\nmousezempic_dosage_data %&gt;%\n  arrange(mouse_strain, weight_lost_g) %&gt;%\n  View()\n\nThis is a great way to check that your code has actually done what you intended!\n\n\n\n2.2.1.1 Extracting rows with the smallest or largest values\nSlice functions are used to select rows based on their position in the data frame. The slice_min() and slice_max() functions are particularly useful, because they allow you to select the rows with the smallest or largest values in a particular column.\nThis is equivalent to using arrange() followed by head(), but is more concise:\n\n# get the 10 mice with the lowest drug dose\nmousezempic_dosage_data %&gt;%\n  # slice_min() requires the column to sort by, and n = the number of rows to keep\n  slice_min(drug_dose_g, n = 10)\n\n# A tibble: 13 × 8\n   mouse_strain cage_number weight_lost_g replicate sex    drug_dose_g\n   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;        &lt;dbl&gt;\n 1 CD-1         3E                   3.15 rep1      female     0.00172\n 2 CD-1         3E                   3.4  rep1      female     0.00174\n 3 CD-1         1A                   3.45 rep3      female     0.00176\n 4 CD-1         2B                   3.25 rep1      female     0.00178\n 5 CD-1         2B                   3.9  rep1      male       0.00178\n 6 CD-1         2B                   2.9  rep2      female     0.00178\n 7 BALB C       2B                   3.25 rep1      female     0.00178\n 8 CD-1         2B                   2.98 rep1      &lt;NA&gt;       0.00179\n 9 CD-1         1A                   3.7  rep1      &lt;NA&gt;       0.0018 \n10 CD-1         3E                   3.6  rep1      male       0.0018 \n11 CD-1         3E                   3.8  rep1      male       0.0018 \n12 CD-1         3E                   3.95 rep1      male       0.0018 \n13 CD-1         2B                   3.55 rep1      female     0.0018 \n# ℹ 2 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;\n\n# get the top 5 mice that lost the most weight\nmousezempic_dosage_data %&gt;%\n  # slice_max() has the same arguments as slice_min()\n  slice_max(weight_lost_g, n = 5)\n\n# A tibble: 6 × 8\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n1 Black 6      3E                   6.3  rep1      male      0.00221\n2 Black 6      3E                   6.05 rep1      male      0.0023 \n3 Black 6      3E                   6    rep2      male      0.0022 \n4 Black 6      3E                   6    rep3      male      0.00222\n5 Black 6      3E                   5.95 rep2      male      0.00223\n6 Black 6      3E                   5.95 rep3      male      0.00229\n# ℹ 2 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;\n\n\nBut wait– neither of those pieces of code actually gave the number of rows we asked for! In the first example, we asked for the 10 mice with the lowest drug dose, but we got 13. And in the second example, we asked for the top 5 mice that lost the most weight, but we got 6. Why aren’t the slice_ functions behaving as expected?\nIf we take a look at the help page (type ?slice_min in the console), we learn that slice_min() and slice_max() have an argument called with_ties that is set to TRUE by default. If we want to make sure we only get the number of rows we asked for, we would have to set it to FALSE, like so:\n\n# get the top 5 mice that lost the most weight\nmousezempic_dosage_data %&gt;%\n  # no ties allowed!\n  slice_max(weight_lost_g, n = 5, with_ties = FALSE)\n\n# A tibble: 5 × 8\n  mouse_strain cage_number weight_lost_g replicate sex   drug_dose_g\n  &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;       &lt;dbl&gt;\n1 Black 6      3E                   6.3  rep1      male      0.00221\n2 Black 6      3E                   6.05 rep1      male      0.0023 \n3 Black 6      3E                   6    rep2      male      0.0022 \n4 Black 6      3E                   6    rep3      male      0.00222\n5 Black 6      3E                   5.95 rep2      male      0.00223\n# ℹ 2 more variables: tail_length_mm &lt;dbl&gt;, initial_weight_g &lt;dbl&gt;\n\n\nThis is an important lesson: sometimes functions will behave in a way that is unexpected, and you might need to read their help page or use other guides/google/AI to understand why.\n\n\n\n\n\n\nPractice exercises\n\n\n\nTry these practice questions to test your understanding\n\n1. Which code would you use to sort the mousezempic_dosage_data data frame from biggest to smallest initial weight?\n\n\n\n\n ✗mousezempic_dosage_data %&gt;% sort(initial_weight_g)\n\n\n ✗mousezempic_dosage_data %&gt;% arrange(initial_weight_g)\n\n\n ✗mousezempic_dosage_data %&gt;% sort(descending(initial_weight_g))\n\n\n ✔mousezempic_dosage_data %&gt;% arrange(desc(initial_weight_g))\n\n\n\n\n\n\n2. Which code would you use to extract the 3 mice with the highest initial weight from the mousezempic_dosage_data data frame?\n\n\n\n\n ✔mousezempic_dosage_data %&gt;% slice_max(initial_weight_g, n = 3)\n\n\n ✗mousezempic_dosage_data %&gt;% arrange(desc(initial_weight_g))\n\n\n ✗mousezempic_dosage_data %&gt;% slice_min(initial_weight_g, n = 3)\n\n\n ✗mousezempic_dosage_data %&gt;% arrange(initial_weight_g)\n\n\n\n\n\n\n3. I’ve written the below code, but one of the comments is messing it up! Which one?\n\n# comment A\nmousezempic_dosage_data # comment B %&gt;%\n  # comment C\n  slice_max(weight_lost_g, n = 5, with_ties = FALSE) # comment D\n\n\n\n\n\n ✗Comment A\n\n\n ✔Comment B\n\n\n ✗Comment C\n\n\n ✗Comment D\n\n\n\n\n\n\n\nSolutions\n\n\nThe correct code to sort the mousezempic_dosage_data data frame from biggest to smallest initial weight is mousezempic_dosage_data %&gt;% arrange(desc(initial_weight_g)). The arrange() function is used to sort the data frame (although there is a sort() function in R, that’s not part of dplyr and won’t work the same way), and the desc() function is used to sort in descending order.\nThe correct code to extract the 3 mice with the highest initial weight from the mousezempic_dosage_data data frame is mousezempic_dosage_data %&gt;% slice_max(initial_weight_g, n = 3). The slice_max() function is used to select the rows with the largest values in the initial_weight_g column, and the n = 3 argument specifies that we want to keep 3 rows. The arrange() function is not needed in this case, because slice_max() will automatically sort the data frame by the specified column.\nThe comment that is messing up the code is Comment B. The # symbol is before the pipe operator %&gt;%, so R treats it as part of the comment and this breaks our chain of pipes. The other comments are fine, because they are either at the end of the line or on their own line. Basically, if a comment is changing the colour of the pipe operator (or any other bits of your code), it’s in the wrong place!\n\n\n\n\n\n\n\n2.2.2 Filtering data\nfilteR for rows\n\n\n2.2.3 Dealing with missing values\nhow to find missing values mention that you\n\n\n2.2.4 Selecting columns\nseleCt for columns\n\n\n2.2.5 Modifying data\nwith mutate()\n\n\n2.2.6 Summarising data\n\nmention that this works with summarize() as well\nexample of calculating mean/median etc",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#sec-grouping",
    "href": "session_2.html#sec-grouping",
    "title": "2  Session 2: Working with data",
    "section": "2.3 Grouping",
    "text": "2.3 Grouping\n\nteaching grouping with the .by argument in other functions\ndemonstrate the powerful combo of grouping + summarising",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#reshaping-and-combining-data",
    "href": "session_2.html#reshaping-and-combining-data",
    "title": "2  Session 2: Working with data",
    "section": "2.4 Reshaping and combining data",
    "text": "2.4 Reshaping and combining data\n\n2.4.1 Reshaping data with pivot functions\n\nbrief introduction to pivoting\nneed to think of some kind of meaningful example for this\n\n\n\n2.4.2 Combining data with join functions\n\nleft_join() example",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#sec-saving",
    "href": "session_2.html#sec-saving",
    "title": "2  Session 2: Working with data",
    "section": "2.5 Saving data to a file",
    "text": "2.5 Saving data to a file\nwrite_* family of functions",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_2.html#summary",
    "href": "session_2.html#summary",
    "title": "2  Session 2: Working with data",
    "section": "2.6 Summary",
    "text": "2.6 Summary\n\n2.6.1 Practice questions",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Session 2: Working with data</span>"
    ]
  },
  {
    "objectID": "session_3.html",
    "href": "session_3.html",
    "title": "3  Session 3: Plotting with ggplot",
    "section": "",
    "text": "3.1 Building our first plot, layer by layer\nIn this session we will learn how to create and customise plots using the ggplot2 package.\nin this session we will use the ggplot2 package\nwe use + for ggplot because + looks like the t in ploT",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Session 3: Plotting with ggplot</span>"
    ]
  },
  {
    "objectID": "session_3.html#building-our-first-plot-layer-by-layer",
    "href": "session_3.html#building-our-first-plot-layer-by-layer",
    "title": "3  Session 3: Plotting with ggplot",
    "section": "",
    "text": "3.1.1 Initialisation\nexplain the basics of data, aes(x = …, y = …)\nwe can pipe data into our ggplot, but don’t recommend it unless the data transformation is really lightweight\n\n\n3.1.2 Adding data\ngeom_* functions\n\n\n3.1.3 Overlaying additional data\nadding more stuff to aes() e.g. colours, shapes of points\nadd more layers to plots e.g. horizontal line or regression line\n\n\n3.1.4 Saving plots as images\nggsave() or export panel",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Session 3: Plotting with ggplot</span>"
    ]
  },
  {
    "objectID": "session_3.html#working-with-scales",
    "href": "session_3.html#working-with-scales",
    "title": "3  Session 3: Plotting with ggplot",
    "section": "3.2 Working with scales",
    "text": "3.2 Working with scales\nlog transformation, changing colour palette",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Session 3: Plotting with ggplot</span>"
    ]
  },
  {
    "objectID": "session_3.html#making-a-plot-pretty",
    "href": "session_3.html#making-a-plot-pretty",
    "title": "3  Session 3: Plotting with ggplot",
    "section": "3.3 Making a plot pretty",
    "text": "3.3 Making a plot pretty\nhere are some common things you might want to do to customise your plot\n\n3.3.1 Labels and text\nadding title, axis labels\nchanging size etc to be readable\nhow to remove scientific notation on axes\n\n\n3.3.2 Themes\nintroduce concept of themes\nhow to modify parts of themes\n\n\n3.3.3 Changing colours/sizes/shapes\nexactly what it sounds like\nmention about\n\n\n3.3.4 Legends\nchanging position, removing it",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Session 3: Plotting with ggplot</span>"
    ]
  },
  {
    "objectID": "session_3.html#making-many-similar-plots-with-facets",
    "href": "session_3.html#making-many-similar-plots-with-facets",
    "title": "3  Session 3: Plotting with ggplot",
    "section": "3.4 Making many similar plots with facets",
    "text": "3.4 Making many similar plots with facets\nhow to facet with facet_wrap() and scales = “free” or not",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Session 3: Plotting with ggplot</span>"
    ]
  },
  {
    "objectID": "session_3.html#laying-out-multiple-plots-into-a-single-figure",
    "href": "session_3.html#laying-out-multiple-plots-into-a-single-figure",
    "title": "3  Session 3: Plotting with ggplot",
    "section": "3.5 Laying out multiple plots into a single figure",
    "text": "3.5 Laying out multiple plots into a single figure\ncombining plots with patchwork",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Session 3: Plotting with ggplot</span>"
    ]
  },
  {
    "objectID": "session_3.html#summary",
    "href": "session_3.html#summary",
    "title": "3  Session 3: Plotting with ggplot",
    "section": "3.6 Summary",
    "text": "3.6 Summary\n\n3.6.1 Practice questions",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Session 3: Plotting with ggplot</span>"
    ]
  },
  {
    "objectID": "session_4.html",
    "href": "session_4.html",
    "title": "4  Session 4: Putting it all together",
    "section": "",
    "text": "4.1 Introduction to the dataset\nIn this session we will combine all the skills we have learned so far to perform a complete analysis of a (small) dataset\ndescribe the fake experiment setup and the data files you will start with",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Session 4: Putting it all together</span>"
    ]
  },
  {
    "objectID": "session_4.html#exploring-the-data",
    "href": "session_4.html#exploring-the-data",
    "title": "4  Session 4: Putting it all together",
    "section": "4.2 Exploring the data",
    "text": "4.2 Exploring the data\nin this step we get familiar with the dataset and think about what sorts of plots we can make/things we can look at",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Session 4: Putting it all together</span>"
    ]
  },
  {
    "objectID": "session_4.html#manipulating-the-data",
    "href": "session_4.html#manipulating-the-data",
    "title": "4  Session 4: Putting it all together",
    "section": "4.3 Manipulating the data",
    "text": "4.3 Manipulating the data\nin this step we will use dplyr to get the data frame into a form that will allow us to answer the questions we came up with above",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Session 4: Putting it all together</span>"
    ]
  },
  {
    "objectID": "session_4.html#visualising-the-data",
    "href": "session_4.html#visualising-the-data",
    "title": "4  Session 4: Putting it all together",
    "section": "4.4 Visualising the data",
    "text": "4.4 Visualising the data\nfinally we will make some nice visualisations\nif time, i think it would be nice to include (briefly) tables with the gt() package.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Session 4: Putting it all together</span>"
    ]
  },
  {
    "objectID": "session_5.html",
    "href": "session_5.html",
    "title": "5  Session 5: RNA-seq part 1",
    "section": "",
    "text": "5.1 DGEList\nIn this session we will run through the basic steps for analysing a simple RNA-seq experiment using the limma-voom workflow. This includes:\nThe aim of this session is to give you experience with a real-world RNA-seq analysis, and making extensive use of an external library. We will not cover the statistics in any depth. In general analysis packages will want your data in some specific format, so it’s important to be able to manipulate the data to fit the package’s requirements.\nMuch of the materials here are explained in greater detail in the limma user’s guide. You can view this by typing help(\"limma\") and following the links.\nThe data we are looking at comes from three cell populations (basal, luminal progenitor (LP) and mature luminal (ML)) sorted from the mammary glands of female virgin mice, each profiled in triplicate.\nLet’s start by creating our DGEList object. As a reminder, this object contains 3 key pieces of data:\n# load required packages\nlibrary(edgeR)\n\nLoading required package: limma\n\nlibrary(limma)\nlibrary(readr)\noptions(readr.show_col_types = FALSE)\n\n# vector of file names\nfiles &lt;- dir(path = \"data/counts\", pattern = \"GSM\")\ngroup &lt;- factor(c(\"LP\", \"ML\", \"Basal\", \"Basal\",\n                  \"ML\", \"LP\", \"Basal\", \"ML\", \"LP\"))\nsamplenames &lt;- c(\"10_6_5_11\", \"9_6_5_11\", \"purep53\", \"JMS8-2\", \"JMS8-3\",\n                 \"JMS8-4\", \"JMS8-5\", \"JMS9-P7c\", \"JMS9-P8c\")\n\n\n# create DGEList object\ndge &lt;- readDGE(\n  files,\n  path = \"data/counts\",\n  columns = c(1, 3),\n  group = group,\n  labels = samplenames\n)\n\n# add gene annotation information\ndge$genes &lt;- read_delim(\"data/Ses3_geneAnnot.tsv\")\nYou can index the DGEList object by treating it as if it were the counts matrix, the object will handle the extraction and ordering of the sample and gene annotation data frames.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Session 5: RNA-seq part 1</span>"
    ]
  },
  {
    "objectID": "session_5.html#dgelist",
    "href": "session_5.html#dgelist",
    "title": "5  Session 5: RNA-seq part 1",
    "section": "",
    "text": "counts: the main data of this object, a matrix of count values with samples along the columns and features/genes along the rows.\nsamples: a data frame containing annotation for the samples. The rows in this table describe the corresponding column of the counts data.\ngenes: a data frame containing annotation for the genes in the counts matrix. The rows in this table describe the corresponding row in the counts matrix.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Session 5: RNA-seq part 1</span>"
    ]
  },
  {
    "objectID": "session_5.html#filtering",
    "href": "session_5.html#filtering",
    "title": "5  Session 5: RNA-seq part 1",
    "section": "5.2 Filtering",
    "text": "5.2 Filtering\nThe first step is to filter out lowly expressed genes. There are two main problems with low abundant genes:\n\nTechnical variation is more problematic for low abundance genes. This variation is thought to be due to two factors; insufficient mixing and low sampling fraction1.\n\nInsufficient mixing of solutions during library preparation can result in uneven distribution of reads.\nRNA sequencing can be thought of as sampling. Measurement errors will occur simply due to the random nature of the sampling process. This problem affects lowly abundant RNA species more because the relative error for small count values is larger than it would be for more highly abundant RNA species.\n\nBiologically, genes that are expressed at low, biologically not meaningful, levels are not of interest.\n\nRemoving these highly variable, lowly expressed genes increases your ‘power’ to detect differentially expressed genes2, where ‘power’ is your ability to detect true positives. In testing for differential expression, a statistical test is conducted for each gene. When a high number of statistical tests are performed, a portion of them will be significant purely due to random chance. A common procedure to control for the number of false positive is to perform ‘multiple testing correction’ on the p-values. This adjusts the p-value in a way that reduces the number of false positives but comes at the cost of reduced power to detect true positives. If we filter out uninteresting, lowly expressed genes, we need to perform fewer statistical tests and reduce the impact that multiple testing adjustment has on detection power.\nThe filterByExpr() function provides an automatic way to filter genes.\nRoughly speaking, by default, it keeps genes with a count of 10 or more, in at least as many samples as the smallest experimental group. In our experiment, there are 3 phenotype groups each with 3 samples. Therefore we retain only genes that have 10 or more counts in 3 or more samples.\nMore specifically, the actual filtering is done on counts per million, with similar result to the above criteria. This is to prevent bias against samples with small library sizes.\nThe output of this function is a vector of logicals, indicating which genes (rows) should be kept and which filtered.\n\nkeep &lt;- filterByExpr(dge)\ntable(keep)\n\nkeep\nFALSE  TRUE \n10555 16624 \n\ndge &lt;- dge[keep, , keep.lib.sizes = FALSE]\ndim(dge$counts)\n\n[1] 16624     9\n\n\nWe can see that we now have 16624 genes. We started with 27179 genes - meaning that ~40% of genes have been filtered out.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Session 5: RNA-seq part 1</span>"
    ]
  },
  {
    "objectID": "session_5.html#normalisation",
    "href": "session_5.html#normalisation",
    "title": "5  Session 5: RNA-seq part 1",
    "section": "5.3 Normalisation",
    "text": "5.3 Normalisation\nThe aim of normalisation is to remove systematic technical effects. There are two main factors that need to be normalised for in RNA-seq:\n\nSequencing depth/library size - technically, sequencing a sample to half the depth will give, on average, half the number of reads mapping to each gene3.\nRNA composition - if a large number of genes are unique to, or highly expressed in, only one experimental condition, the sequencing capacity available for the remaining genes in that sample is decreased. For example, if there are only five genes being studied in two experimental groups, if one gene is particularly high in group A, then with limited sequencing depth, that gene will reduce the counts of the remaining four genes. The effect of this is that the remaining four genes appear under-expressed in group A compared to group B when the true amount of gene product is actually equal for these 4 genes3.\n\nSequencing depth is accounted for by calculating the counts per million (cpm). This metric is calculated by:\n\ntaking the library size (sum of all counts for a sample),\ndividing this by 1,000,000 to get the ‘per million’ scaling factor,\nthen dividing all read counts for each gene in that sample by the ‘per million’ scaling factor\n\nRNA composition can be accounted for by using more sophisticated normalisation methodologies. We will use ‘trimmed mean of M-values’ (TMM), which estimates relative RNA levels from RNA-seq data3. Under the assumption that most genes are not differentially expressed, TMM calculates a library size scaling factor for each library (sample). This is done using the following steps:\n\ncalculate the gene expression log fold changes and absolute expression values for pair-wise samples (selecting one sample from the experiment as a reference)\nremove the genes with the highest and lowest fold changes and absolute expression values\ntake a weighted mean of the remaining genes (where the weight is the inverse of the approximate asymptotic variances). This gives the normalisation factor for each library (sample)\n\nSubsequent steps in this analysis will use log-cpm values, calculated using the normalisation factors, which scales each library size.\nWe can calculate the normalisation factors, specifying that we want to use the \"TMM\" method:\n\ndge &lt;- calcNormFactors(dge, method = \"TMM\")\n\nThis function calculates the normalisation factors for each library (sample) and puts this information in the samples data frame. Note that it takes dge (our DGEList object as input) and returns a DGEList object as well.\nLet’s take a look at our normalisation factors:\n\ndge$samples\n\n                             files group lib.size norm.factors\n10_6_5_11 GSM1545535_10_6_5_11.txt    LP 32857304    0.8943956\n9_6_5_11   GSM1545536_9_6_5_11.txt    ML 35328624    1.0250186\npurep53     GSM1545538_purep53.txt Basal 57147943    1.0459005\nJMS8-2       GSM1545539_JMS8-2.txt Basal 51356800    1.0458455\nJMS8-3       GSM1545540_JMS8-3.txt    ML 75782871    1.0162707\nJMS8-4       GSM1545541_JMS8-4.txt    LP 60506774    0.9217132\nJMS8-5       GSM1545542_JMS8-5.txt Basal 55073018    0.9961959\nJMS9-P7c   GSM1545544_JMS9-P7c.txt    ML 21305254    1.0861026\nJMS9-P8c   GSM1545545_JMS9-P8c.txt    LP 19955335    0.9839203\n\n\nThese normalisation factors are all close to 1 for all samples, suggesting minimal difference in relative RNA levels between samples.\n\nboxplot(log(dge$counts + 0.5))\n\n\n\n\n\n\n\n\n\nboxplot(cpm(dge$counts, log = TRUE))",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Session 5: RNA-seq part 1</span>"
    ]
  },
  {
    "objectID": "session_5.html#mds-plots",
    "href": "session_5.html#mds-plots",
    "title": "5  Session 5: RNA-seq part 1",
    "section": "5.4 MDS plots",
    "text": "5.4 MDS plots\nBefore we perform statistical tests, it’s useful to perform some exploratory visual analysis to get an overall idea of how our data is behaving.\nMDS is a way to visualise distances between sets of data points (samples in our case). It is a dimensionality reduction technique, similar to principal components analysis (PCA). We treat gene expression in samples as if they were coordinates in a high-dimensional coordinate system, then we can find “distances” between samples as we do between points in space. Then the goal of the algorithm is to find a representation in lower dimensional space such that points that the distance of two objects from each other in high dimensional space is preserved in lower dimensions.\nThe plotMDS() from limma creates an MDS plot from a DGEList object.\n\nplotMDS(dge)\n\n\n\n\n\n\n\n\nEach point on the plot represents one sample and is ‘labelled’ using the sample name. The distances between each sample in the resulting plot can be interpreted as the typical log2-fold-change between the samples, for the most differentially expressed genes.\nWe can change the labelling to use the name of the group the sample belongs to instead:\n\nplotMDS(dge, labels = group)\n\n\n\n\n\n\n\n\nThis shows us that the phenotype groups tend to cluster together, meaning that the gene expression profiles are similar for samples within a phenotype group. The ‘Basal’ type samples quite close together while the ‘LP’ (luminal progenitor) and ‘ML’ (mature luminal) type samples are further apart, signifying that their expression profiles are more variable.\nTo make the three phenotype groups more distinct in our graph, we are going to colour samples from each group differently. To do this, we will use the col argument in plotMDS(). col takes in a vector the same length as the number of points in the plot (9 in our case, as there are 9 samples). Each element of the vector should be a colour name (R understands over 600 colour names), indicating what colour that sample should be.\nTo make this more clear, take a look at the table below, which lists all the samples and the phenotype group they belong to:\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ purrr     1.0.2\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ tidyr::extract()    masks magrittr::extract()\n✖ dplyr::filter()     masks stats::filter()\n✖ dplyr::group_rows() masks kableExtra::group_rows()\n✖ dplyr::lag()        masks stats::lag()\n✖ purrr::set_names()  masks magrittr::set_names()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\n\n\nSamples\nGroup\n\n\n\n\n10_6_5_11\nLP\n\n\n9_6_5_11\nML\n\n\npurep53\nBasal\n\n\nJMS8-2\nBasal\n\n\nJMS8-3\nML\n\n\nJMS8-4\nLP\n\n\nJMS8-5\nBasal\n\n\nJMS9-P7c\nML\n\n\nJMS9-P8c\nLP\n\n\n\n\n\n\n\nFor example, let’s say we wanted LP samples to be coloured green, ML samples to be coloured red and Basal samples to be coloured blue. The col argument would then require a vector that we can generate as follows\n\ngroup_col &lt;- dge$samples$group\nlevels(group_col) &lt;- c(\"blue\", \"green\", \"red\")\ngroup_col &lt;- as.character(group_col)\ngroup_col\n\n[1] \"green\" \"red\"   \"blue\"  \"blue\"  \"red\"   \"green\" \"blue\"  \"red\"   \"green\"\n\n\nWe can also add a legend to the figure by running the legend() function immediately after a new figure is created. We have to specify where to position the legend as well as the labels and colours within the legend.\nTODO: Helper functions? TODO: Convert all plots to ggplot and provide reasoning\n\nmds_data &lt;- plotMDS(dge, labels = group, col = group_col)\nlegend(\n  \"topright\",\n  legend = c(\"Basal\", \"LP\", \"ML\"),\n  fill = c(\"blue\", \"green\", \"red\")\n)\n\n\n\n\n\n\n\nmds_tibble &lt;- tibble(\n    x = mds_data$x,\n    y = mds_data$y,\n    label = colnames(dge),\n    group = dge$samples$group\n)\n\nmds_tibble %&gt;%\n    ggplot(aes(x = x, y = y, col = group)) +\n    geom_point(size = 3)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Session 5: RNA-seq part 1</span>"
    ]
  },
  {
    "objectID": "session_5.html#references",
    "href": "session_5.html#references",
    "title": "5  Session 5: RNA-seq part 1",
    "section": "5.5 References",
    "text": "5.5 References\n\n\n\n\n\n\n1. McIntyre LM, Lopiano KK, Morse AM, Amin V, Oberg AL, Young LJ, et al. RNA-seq: technical variability and sampling. BMC Genomics [Internet]. 2011 Jun 6;12(1). Available from: http://dx.doi.org/10.1186/1471-2164-12-293\n\n\n2. Bourgon R, Gentleman R, Huber W. Independent filtering increases detection power for high-throughput experiments. Proceedings of the National Academy of Sciences [Internet]. 2010 May 11;107(21):9546–51. Available from: http://dx.doi.org/10.1073/pnas.0914005107\n\n\n3. Robinson MD, Oshlack A. A scaling normalization method for differential expression analysis of RNA-seq data. Genome Biology [Internet]. 2010 Mar 2;11(3). Available from: http://dx.doi.org/10.1186/gb-2010-11-3-r25",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Session 5: RNA-seq part 1</span>"
    ]
  },
  {
    "objectID": "session_6.html",
    "href": "session_6.html",
    "title": "6  Session 6: RNA-seq part 2",
    "section": "",
    "text": "6.1 Linear modelling\nThe next step of the limma-voom analysis is to fit a linear model for each gene. A linear model is a broad class of statistical models that predict a variable of interest using one or more ‘explanatory’ (also called ‘predictor’) variables. The most basic type is linear regression, which models the relationship between a continuous variable and continuous or categorical ‘explanatory’ variables. It uses an equation that looks like this:\n\\(Y = \\beta_{0} + \\beta_{1}X_{1} + \\beta_{2}X_{2}...\\)\nThis equation is saying that a response variable of interest \\(Y\\) is equal to a constant (\\(\\beta_{0}\\)) plus the sum of the covariates (\\(X_{i}\\)) each multiplied by a constant coefficient (\\(\\beta_{i}\\)).\nOur experiment is quite simple, since there is only a single covariate, the cell type. The true benefit of using linear models is in its ability to accommodate more complex designs including multiple covariates.\nTo fit the linear models in the limma-voom framework we need two objects in addition to our data:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Session 6: RNA-seq part 2</span>"
    ]
  },
  {
    "objectID": "session_6.html#linear-modelling",
    "href": "session_6.html#linear-modelling",
    "title": "6  Session 6: RNA-seq part 2",
    "section": "",
    "text": "A design matrix, representing the covariates.\nA contrast matrix, representing the specific comparison we wish to make.\n\n\n6.1.1 Design matrix\nThe design matrix specifies the values of the covariates for each sample. This is represented as a matrix due to the mathematical convenience.\nTo generate a design matrix. We use the function model.matrix(), with the expression ~0 + group. This returns a matrix representing the design where there is no intercept term and group is the only covariate. If we omit the 0 then there would be an intercept in the model, and if we included more covariates then more columns would be generated.\n\ndesign &lt;- model.matrix(~0 + group, data = dge$samples)\ndesign\n\n          groupBasal groupLP groupML\n10_6_5_11          0       1       0\n9_6_5_11           0       0       1\npurep53            1       0       0\nJMS8-2             1       0       0\nJMS8-3             0       0       1\nJMS8-4             0       1       0\nJMS8-5             1       0       0\nJMS9-P7c           0       0       1\nJMS9-P8c           0       1       0\nattr(,\"assign\")\n[1] 1 1 1\nattr(,\"contrasts\")\nattr(,\"contrasts\")$group\n[1] \"contr.treatment\"\n\n\nThere are 9 rows, one for each sample. Along the columns are the names of the groups. The values in the cells denote membership of the particular sample for a particular group, as our groups in this case are mutually exclusive, each row contains only a single 1 to denote membership in a single group.\n\n\n6.1.2 Contrasts\n‘Contrasts’ let us ask specific questions between our experimental groups. In our data we have 3 experimental groups, if we are to test for differential expression, we are most likely interested in differences between only two of the groups at a time. Contrasts let us specify exactly what we’re testing for, and is also represented by a matrix just like the design.\nA contrast matrix can be made using the makeContrasts() function. Within this function, we specify the name of each specific contrast and the formula for that contrast. For example, the BasalvsLP contrasts compares the difference between the Basal and LP groups. Note that the name of the phenotype groups must be written exactly as they are in the column names of our design matrix (see above).\nIn addition to the individual contrasts, the function must know about the design of the model. This is passed through the levels argument, which either accepts a matrix with the column names corresponding to levels of your experimental groups, or the levels themselves as a character vector\n\ncontr.matrix &lt;- makeContrasts(\n  BasalvsLP = \"Basal - LP\",\n  BasalvsML = \"Basal - ML\",\n  LPvsML = \"LP - ML\",\n  levels = design) # alternatively 'levels = colnames(design)'\ncontr.matrix\n\n       Contrasts\nLevels  BasalvsLP BasalvsML LPvsML\n  Basal         1         1      0\n  LP           -1         0      1\n  ML            0        -1     -1\n\n\nNote that the sum of all the numbers along each column is 0. The first column is the contrast for the difference between Basal (1) and LP (-1). This property is required for valid contrast matrices. An alternative test may be between one group and the average of the others which would look like c(1, -0.5, -0.5) down one of the columns.\n\n\n6.1.3 Variance modelling with voom\nWe are now ready to fit our linear models. Limma fits linear models to the data with the assumption that the underlying data is normally distributed. Count data is generally not normally distributed, but log transforming count data gives it a roughly normal distribution sufficient for linear models to work well. To do this, limma transforms the raw count data to log-cpm using library sizes and the normalisation factors we calculated previously.\nIn addition to the normalisation steps, the limma-voom pipeline uses the voom() function to generate weights for the individual genes based on a modelled mean-variance relationship. This modelling allows use to get more information out of small sample sizes as the weights prevent our model from being more heavily influenced by more variable data points.\nThe voom() function takes as arguments, our DGEList object and our design matrix. It also optionally outputs a plot of the mean-variance relationship of our data, called the ‘voom-plot’.\n\nv &lt;- voom(dge, design, plot = TRUE)\n\n\n\n\n\n\n\n\nThe output of voom() (our variable v) is an EList object which contains the following elements:\n\ngenes - a data frame of gene annotation data.\ntargets - data frame of sample data.\nE - numeric matrix of normalised log-cpm values.\nweights - numeric matrix of precision weights.\ndesign - the design matrix.\n\n\n\n6.1.4 Fitting the linear model\nWe are now ready to fit our linear model with lmFit(), which calculates coefficients we defined in our design matrix design. The resulting object, vfit is a MArrayLM object. It contains a information about our genes (the same data frame as genes from our EList object v above), the design matrix and a number of statistical outputs. Of most interest to us is the coefficients, stored in an element called coefficients. The first rows of this matrix is shown below. Each gene is row and is labelled using the EntrezID. Each column gives coefficients for each of our phenotype groups. These coefficients are weighted averages of the log-cpm of each gene in each group.\n\nvfit &lt;- lmFit(v, design)\nhead(vfit$coefficients)\n\n               Basal        LP        ML\n497097     3.0677957 -4.578216 -3.854848\n100503874 -3.2300807 -6.118256 -6.305207\n100038431 -6.2389112 -6.118256 -6.305207\n19888     -6.7677975 -5.284107 -3.387890\n20671      0.3134058 -2.601497 -1.960416\n27395      4.3656951  3.792765  4.417114\n\n\nWe can then use contrasts.fit() to calculate coefficients for each contrast (or ‘comparison’) we specified in our contr.matrix. The output is also an object of the class MArrayLM (also known as an MArrayLM object). When we inspect the coefficients element now, we can see that each column is a contrast that we specified in our contrast matrix.\n\nvfit &lt;- contrasts.fit(vfit, contrasts = contr.matrix)\nhead(vfit$coefficients)\n\n           Contrasts\n             BasalvsLP   BasalvsML     LPvsML\n  497097     7.6460121  6.92264390 -0.7233682\n  100503874  2.8881750  3.07512580  0.1869508\n  100038431 -0.1206555  0.06629528  0.1869508\n  19888     -1.4836903 -3.37990752 -1.8962172\n  20671      2.9149031  2.27382208 -0.6410810\n  27395      0.5729302 -0.05141909 -0.6243493",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Session 6: RNA-seq part 2</span>"
    ]
  },
  {
    "objectID": "session_6.html#statistical-testing",
    "href": "session_6.html#statistical-testing",
    "title": "6  Session 6: RNA-seq part 2",
    "section": "6.2 Statistical testing",
    "text": "6.2 Statistical testing\nThe next step is to carry out statistical testing to determine which genes are differentially expressed. The function eBayes() computes moderated t-statistics, moderated F-statistics and log-odds of differential expression for each gene, given a fitted linear model. ‘Moderated’ refers to empirical Bayes moderation, which borrows information across genes to obtain more accurate measures of variability for each gene. This also increases our power to detect differentially expressed genes.\n\nefit &lt;- eBayes(vfit)\n\nWe can now look at the number of differentially expressed genes using the decideTests() function. The output of this function is a matrix where each column is a contrast (comparison of interest) and each row is a gene. The numbers 1, -1 and 0 mean up-regulated, down-regulated or not significantly differentially expressed, respectively.\nNote that decideTests() also accounts for multiple testing. The default method is Benjamini and Hochberg1 but several others are also available.\n\ndt &lt;- decideTests(efit)\ndt\n\nTestResults matrix\n           Contrasts\n            BasalvsLP BasalvsML LPvsML\n  497097            1         1      0\n  100503874         1         1      0\n  100038431         0         0      0\n  19888             0        -1      0\n  20671             1         1      0\n27174 more rows ...\n\n\nTo obtain the total number of differentially expressed genes for each comparison, we can add the function summary():\n\nsummary(dt)\n\n       BasalvsLP BasalvsML LPvsML\nDown        3877      5004   3472\nNotSig     17519     17182  22163\nUp          5783      4993   1544\n\n\nThe function topTable() can be used to obtain more information on the differentially expressed genes for each contrast. topTable() takes as arguments the MArrayLM object output by eBayes() (efit), the contrast name of interest and the number of top differentially expressed genes to output. Note that the contrast name must be given in quotes and must be exactly as written in the contrast matrix contr.matrix.\nIt outputs a data frame with the following information:\n\nGene details - gene information, from the gene element of the MArrayLM object (efit).\nlogFC - the log2 fold change of the contrast.\nAveExpr - the average log2 expression of that gene.\nt - moderated t-statistic.\nP.Value - p value.\nadj.P.Val - adjusted p value.\nB - log-odds that the gene is differentially expressed.\n\n\ntop &lt;- topTable(efit, coef = \"BasalvsLP\", n = Inf)\nhead(top)\n\n      ENTREZID  SYMBOL TXCHROM     logFC   AveExpr         t      P.Value\n12759    12759     Clu   chr14 -5.177621  8.856284 -32.49244 6.107092e-14\n12521    12521    Cd82    chr2 -3.954595  7.069340 -31.24164 1.016658e-13\n16324    16324   Inhbb    chr1 -4.589997  6.460624 -29.97109 1.741973e-13\n53624    53624   Cldn7   chr11 -5.239579  6.295139 -28.23838 3.767208e-13\n26943    26943 Serinc3    chr2 -3.231408 10.189462 -27.41397 5.526704e-13\n14245    14245   Lpin1   chr12 -3.622175  6.293719 -27.53676 5.216399e-13\n         adj.P.Val        B\n12759 1.381587e-09 22.33748\n12521 1.381587e-09 21.77472\n16324 1.578169e-09 21.20649\n53624 1.630073e-09 20.41463\n26943 1.630073e-09 20.27957\n14245 1.630073e-09 20.26629\n\n\nWith that we can complete our analysis by writing out some results\n\nwrite.csv(top, file = \"BasalvsLP.csv\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Session 6: RNA-seq part 2</span>"
    ]
  },
  {
    "objectID": "session_6.html#ma-plot",
    "href": "session_6.html#ma-plot",
    "title": "6  Session 6: RNA-seq part 2",
    "section": "6.3 MA Plot",
    "text": "6.3 MA Plot\nThe MA plot is a plot of log-fold-change (M-values) against log-expression averages (A-values), this is a common plot in RNA sequencing analysis to visualise the result of differential expression tests. It can be created using the plotMA() from the limma package. Creating this plot requires 3 pieces of information:\n\nobject = efit: The the fitted object containing the log-fold-change and log-expression averages\ncoef = 1: The column number of the contrast to plot since there are 3 different contrasts fitted within the object.\nstatus = dt[, 1]: A vector of numerics denoting whether a gene is up-regulated or down-regulated.\n\n\nplotMA(efit, coef = 1, status = dt[, \"BasalvsLP\"])\n\n\n\n\n\n\n\n\nWe can also save this plot programmatically as a PDF for further editing. To do this we use pdf() to turn on the pdf capture device, run the command that creates the plot, which is now captured by the pdf, and then turn the device off.\n\npdf(file = \"BasalvsLP-MAPlot.pdf\")\nplotMA(efit, coef = 1, status = dt[, \"BasalvsLP\"])\ndev.off()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Session 6: RNA-seq part 2</span>"
    ]
  },
  {
    "objectID": "session_6.html#references",
    "href": "session_6.html#references",
    "title": "6  Session 6: RNA-seq part 2",
    "section": "6.4 References",
    "text": "6.4 References\n\n\n\n\n\n\n1. Benjamini Y, Hochberg Y. Controlling the False Discovery Rate: A Practical and Powerful Approach to Multiple Testing. Journal of the Royal Statistical Society Series B: Statistical Methodology [Internet]. 1995 Jan 1;57(1):289–300. Available from: http://dx.doi.org/10.1111/j.2517-6161.1995.tb02031.x",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Session 6: RNA-seq part 2</span>"
    ]
  },
  {
    "objectID": "further_reading.html",
    "href": "further_reading.html",
    "title": "7  Course summary & next steps",
    "section": "",
    "text": "summarise the course/key points from each session\nput links to more advanced materials",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Course summary & next steps</span>"
    ]
  },
  {
    "objectID": "advanced_topics.html",
    "href": "advanced_topics.html",
    "title": "8  Advanced topics",
    "section": "",
    "text": "Here we could write some stuff about:\n\ncontrol structures (for loops, if/else)\nfunctions\nquarto\n\nOf course this is extra but would be nice to have, potentially for some sort of advanced course in the future",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Advanced topics</span>"
    ]
  }
]